apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xinstances.os.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: os.skycluster.io/v1alpha1
    kind: XInstance
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfigs
              apiVersion: openstack.crossplane.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: XSetup
              apiVersion: os.skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: openstack
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
                  - key: skycluster.io/provider-zone
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.zone
                  - key: skycluster.io/application-id
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.applicationId
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            provider-openstack = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |2-

            import helper.v1alpha1.main as helper
            import provider_openstack.v1alpha1 as opv1a1

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _xsetup = _extraRes["XSetup"][0]
            assert _xsetup is not Undefined, "XSetup must be provided in the extra resources"

            _skySetup = _extraRes["SkySetups"][0]
            assert _skySetup is not Undefined, "SkySetup must be provided in the extra resources"

            _provCfg = _extraRes["ProviderConfigs"]?[0]
            assert _provCfg is not Undefined, "ProviderConfig must be provided in the extra resources"


            _oxrName = oxr.metadata.name
            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zone
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.providerRef.applicationId or Undefined
            _oxrAnnotations = oxr.metadata.annotations

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, \
              "Provider region, primary zone, platform must be specified"

            _openPorts = [
              {"fromPort" = r.fromPort, "toPort" = r.toPort, "protocol" = r.protocol} 
                for r in oxr.spec.securityGroups?.tcpPorts
            ] if oxr.spec.securityGroups?.tcpPorts else []
            _openPorts += [
              {"fromPort" = r.fromPort, "toPort" = r.toPort, "protocol" = r.protocol} 
                for r in oxr.spec.securityGroups?.udpPorts
            ] if oxr.spec.securityGroups?.udpPorts else []

            _items = []

            _defaults = {
              providerConfigRef = {
                name = _provCfg.metadata.name
              },
            }

            _default_labels = {
              **oxr.metadata?.labels,
              **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
            }

            _default_annotations = {
              **oxr.metadata?.annotations,
              **helper._is_paused_label(oxr.metadata.labels),
            }

            _networkId = _xsetup?.status?.vpc?.id
            _subnets = oxr.spec?.subnets or _xsetup?.status?.subnets or []
            _items += [opv1a1.PortV2{
              "metadata": {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("port{}".format(i)),
                },
              },
              spec = _defaults | {
                forProvider = {
                  region = _oxrProvRegion
                  networkId = _networkId
                  fixedIp = [{
                    subnetId = s.id
                  }]
                  if oxr.spec.ipForwarding:
                    portSecurityEnabled = False
                }
              } 
            } for i, s in _subnets] 


            _items += [opv1a1.KeypairV2{
              "metadata": {
                labels = _default_labels | {
                  "skycluster.io/composite-name": _oxrName
                }
                annotations = _default_annotations | {
                  **helper._set_resource_name("keypair"),
                  **helper._external_resources(_oxrAnnotations, "compute.openstack.crossplane.io/v1alpha1", "KeypairV2")
                },
              },
              spec = _defaults | {
                forProvider = {
                  region = _oxrProvRegion
                  name = oxr.metadata.name
                  publicKey = oxr.spec.publicKey
                }
              } | helper._management_policy(_oxrAnnotations, "compute.openstack.crossplane.io/v1alpha1", "KeypairV2")
            }] if oxr.spec.publicKey else []

            _keypairName = ocds?["keypair"]?.Resource?.status?.atProvider?.name if oxr.spec.keyPair else \
              _xsetup.status?.keypair?.name


            _items += [opv1a1.SecgroupV2{
              "metadata": {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("secgroup"),
                  **helper._external_resources(_oxrAnnotations, "networking.openstack.crossplane.io/v1alpha1", "SecgroupV2")
                },
              },
              spec = _defaults | {
                forProvider = {
                  region = _oxrProvRegion
                  name = oxr.metadata.name
                  description = "Security group for {}".format(oxr.metadata.name)
                }
              } | helper._management_policy(_oxrAnnotations, "networking.openstack.crossplane.io/v1alpha1", "SecgroupV2")
            }] if oxr.spec.securityGroups or ocds?["secgroup"] else []


            _tcpPorts = oxr.spec.tcpPorts or []
            _udpPorts = oxr.spec.udpPorts or []

            _items += [opv1a1.SecgroupRuleV2{
              "metadata": {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("secgroupRule{}{}".format(p.protocol, i)),
                },
              },
              spec = _defaults | {
                forProvider = {
                  securityGroupIdSelector.matchControllerRef = True
                  direction = "ingress"
                  ethertype = "IPv4"
                  protocol = p.protocol
                  portRangeMax = p.toPort
                  portRangeMin = p.fromPort
                  remoteIpPrefix = "0.0.0.0/0"
                }
              }
            } for i, p in _tcpPorts]

            # Just get the first IP of the available public subnet
            _extNetworkName = _xsetup.status?.externalNetwork?.networkName

            _items += [opv1a1.FloatingipV2{
              "metadata": {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("floatingip"),
                  **helper._external_resources(_oxrAnnotations, "networking.openstack.crossplane.io/v1alpha1", "FloatingipV2")
                },
              },
              spec = _defaults | {
                forProvider = {
                  region = _oxrProvRegion
                  pool = _extNetworkName
                }
              } | helper._management_policy(_oxrAnnotations, "networking.openstack.crossplane.io/v1alpha1", "FloatingipV2")
            }] if _extNetworkName and oxr.spec.publicIp or ocds?["floatingip"] else []


            _ports = [r.Resource?.status?.atProvider?.id for k, r in ocds if k.find("port") != -1 and r.Resource?.status?.atProvider?.id]
            _portId = _ports?[0] or Undefined
            _floatingIp = ocds?["floatingip"]?.Resource?.status?.atProvider?.address or Undefined
            _instanceIp = ocds?["instance"]?.Resource?.status?.atProvider?.accessIpV4 or Undefined

            _items += [opv1a1.FloatingipAssociateV2{
              "metadata": {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("floatingipAssociate"),
                  **helper._external_resources(_oxrAnnotations, "networking.openstack.crossplane.io/v1alpha1", "FloatingipAssociateV2")
                },
              },
              spec = _defaults | {
                forProvider = {
                  region = _oxrProvRegion
                  fixedIp = _instanceIp
                  floatingIp = _floatingIp
                  portId = _portId
                }
              } | helper._management_policy(_oxrAnnotations, "networking.openstack.crossplane.io/v1alpha1", "FloatingipAssociateV2")
            }] if (_floatingIp and _instanceIp) or ocds?["floatingipAssociate"] else []


            _defaultSecurityGroupId = _xsetup?.status?.securityGroup?.id
            _securityGroupId = ocds?["secgroup"]?.Resource?.status?.atProvider?.id

            _ready_to_create = oxr.spec.ipForwarding or \
              (oxr.spec.securityGroups and _securityGroupId) or \
              (not oxr.spec.securityGroups and _defaultSecurityGroupId)

            # if this instance does not have public IP it should route 
            # its traffic through provider's private IP
            _userData = oxr.spec?.userData
            _userData = _userData.replace("__GW_ADDRESS__", _xsetup?.status?.gateway?.privateIp)

            _items += [opv1a1.InstanceV2{
              "metadata": {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("instance"),
                  **helper._external_resources(_oxrAnnotations, "compute.openstack.crossplane.io/v1alpha1", "InstanceV2")
                },
              },
              spec = _defaults | {
                forProvider = {
                  name = oxr.metadata.name
                  flavorName = oxr.spec?.flavor
                  imageName = oxr.spec?.image
                  keyPair = _keypairName
                  if not oxr.spec.ipForwarding:
                    securityGroups = [_securityGroupId] if oxr.spec.securityGroups else [_defaultSecurityGroupId]
                  network = [{port = _portId}]
                  # SecurityGroups are not needed as we set the port security to false
                  # We should handle security controls within iptables inside the host
                  userData = _userData
                }
              } | helper._management_policy(_oxrAnnotations, "compute.openstack.crossplane.io/v1alpha1", "InstanceV2")
            }] if _portId and _ready_to_create or ocds?["instance"] else []


            dxr = {
              **option("params").dxr,
              status.network = {
                privateIp = _instanceIp or Undefined
                publicIp = _floatingIp or Undefined
              } if _instanceIp or _floatingIp else Undefined,
            }

            items = [*_items, dxr]

    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
