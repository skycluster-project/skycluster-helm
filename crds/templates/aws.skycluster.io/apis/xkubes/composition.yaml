apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xkubes.aws.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: aws.skycluster.io/v1alpha1
    kind: XKube
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfigs
              apiVersion: aws.upbound.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: XSetup
              apiVersion: aws.skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: aws
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
                  - key: skycluster.io/provider-zone
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.zones.primary
                  - key: skycluster.io/application-id
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.applicationId
            - kind: Secret
              into: ConnectionSecrets
              apiVersion: v1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/config-type
                    type: Value
                    value: connection-secret
            - kind: ConfigMap
              into: ProviderSettings
              apiVersion: v1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/config-type
                    type: Value
                    value: provider-profile
                  - key: skycluster.io/provider-platform
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.platform
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            provider-aws = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-helm = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |-
            import json
            import crypto
            import regex
            import helper.v1alpha1.main as helper
            import provider_aws.eks.v1beta1 as eksv1beta1
            import provider_aws.eks.v1beta2 as eksv1beta2
            import provider_aws.iam.v1beta1 as iamv1beta1
            import provider_aws.ec2.v1beta1 as ec2v1beta1
            import provider_kubernetes.v1alpha2 as k8sv1a2

            import provider_aws.sqs.v1beta1 as sqsv1beta1
            import provider_aws.cloudwatchevents.v1beta1 as cloudwatcheventsv1beta1
            import provider_helm.v1beta1 as helmv1b1

            oxr = option("params")?.oxr
            assert oxr.metadata?.labels is not Undefined, "At least one label must be specified"
            assert "skycluster.io/managed-by" in oxr.metadata.labels, "Label 'skycluster.io/managed-by' must be specified"
            ocds = option("params")?.ocds

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            # This is provided by KCL (see extraItem at the end)
            extra = option("params")?.extraResources

            _oxrName = oxr.metadata.name
            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zones.primary
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.providerRef.applicationId or Undefined
            _oxrServiceCidr = oxr.spec.serviceCidr or Undefined

            _provSettings = _extraRes["ProviderSettings"]?[0] 
            assert _provSettings is not Undefined, "Provider settings must be provided in the extra resources"

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, \
              "Provider region, primary zone, platform must be specified"
            assert _oxrServiceCidr, "Service CIDR must be specified in the oxr spec"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _secGroups = extra["securityGroups"] or Undefined

            _provCfg = _extraRes["ProviderConfigs"][0]
            _skySetup = _extraRes["SkySetups"][0]
            _skyK8SProviderCfgName = _skySetup.status?.providerConfig?.kubernetes?.name
            _xSetup = _extraRes["XSetup"][0]
            _conSecret = _extraRes["ConnectionSecrets"][0]
            _ns = "skycluster-system"
            _connectionSecretNamespace = _ns
            _nodeGroups = oxr.spec.nodeGroups
            _principalArn = oxr.spec?.principalArn or Undefined

            _defaults = {
              deletionPolicy = "Delete"
              providerConfigRef.name = _provCfg.metadata.name
            }

            _subnets = [{
              type = "public" 
              cidrBlock = oxr.spec.podCidr.public
              zone = oxr.spec.providerRef.zones.primary
            }, {
              type = "private"
              cidrBlock = oxr.spec.podCidr.private
              zone = oxr.spec.providerRef.zones.secondary
            }]

            _items = []

            _items += [_helper_role("controlplaneRole")]
            _items += [_helper_subnet(i, s) for i, s in _subnets]
            # Route configuration
            # Public route table
            _items += [_helper_route_table("public")]
            _items += [_helper_route_table_association("public")]
            _items += [_helper_route("public")]
            # Private route table
            _items += [_helper_route_table("private")]
            _items += [_helper_route_table_association("private")]
            _items += [_helper_route("private")]

            _subnetsReadiness = all_true(
              [helper._ready(ocds?["subnet{}{}".format("Public" if s.type == "public" else "Private", i)] ) for i, s in _subnets]
            )
            _items += [_helper_cluster("k8sCluster")] if _subnetsReadiness or ocds?["k8sCluster"] else []

            _items += [
              _helper_cluster_auth("k8sAuth")
            ] if helper._ready(ocds?["k8sCluster"]) or ocds?["k8sAuth"] else []

            _items += [_helper_role_node_group("nodegroupRole")]
            _items += [_helper_launch_template()] if _secGroups else []

            _lnchTemplateName = ocds?["lnchTemplatePublic"]?.Resource?.status?.atProvider?.name
            _main_ng = {
              publicAccess = True,
              nodeCount = 2,
              instanceTypes = ["t3.medium"],
              autoScaling = {
                minSize = 2,
                maxSize = 3
              }
            }
            _items += [
              _helper_node_group(1000, _main_ng, _lnchTemplateName)
            ] if (helper._ready(ocds?["vpc-cni-addon"]) and _lnchTemplateName) or ocds?["nodeGroup1000Public"] else []

            # _items += [
            #   # The public node group is used to create nodes acting as gateways for the cluster.
            #   _helper_node_group(i, ng, _lnchTemplateName) for i, ng in _nodeGroups if ng.publicAccess
            # ] if (helper._ready(ocds?["vpc-cni-addon"]) and _lnchTemplateName) or ocds?["nodeGroupPublic0"] else []

            _items += _helper_ebs_role()

            _items += [
              _helper_access_entry(_principalArn),
              _helper_access_policy_assoc(_principalArn)
            ] if _principalArn else []

            _items += [
              _helper_addon_cni()
            ] if helper._ready(ocds?["k8sAuth"]) or ocds?["vpc-cni-addon"] else []


            _nodeGroupReadiness = any_true(
              [helper._ready(ocds?["nodeGroup{}{}".format("Public" if ng.publicAccess else "Private", i)] ) for i, ng in _nodeGroups]
            )

            # TODO: Enable EBS CSI addon when needed
            # _items += [
            #   _helper_addon_csi()
            # ] 
            # if _nodeGroupReadiness or ocds?["aws-ebs-csi-driver-addon"] else []


            _items += [
              _helper_addon_pod_identity()
            ] 
            # if _nodeGroupReadiness or ocds?["eks-pod-identity-agent"] else []

            ##### Karpenter Settings #####

            _items += _helper_karpenter_roles(_oxrName)
            _items += _helper_karpenter_sqs_cloudwatch(_oxrName)

            _ProvCfgHelmName = ocds?["providerConfigHelm"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
            _items += [_helper_karpenter_helm(
              ocds?["k8sCluster"]?.Resource?.metadata?.name,
              ocds?["karpenterSQS"]?.Resource?.status?.atProvider?.name,
              _ProvCfgHelmName
            )] if (helper._ready(ocds?["k8sCluster"]) and _ProvCfgHelmName) or ocds?["karpenterChart"] else []

            _statusAccountId = regex.replace(ocds?["karpenterInstanceNodeRole"]?.Resource?.status?.atProvider?.arn, "arn:aws:iam::(\d+):.*", "$1")
            _items += _helper_karpenter_pod_identity(
              ocds?["k8sCluster"]?.Resource?.metadata?.name,
              ocds?["karpenterSQS"]?.Resource?.status?.atProvider?.arn,
              ocds?["karpenterInstanceNodeRole"]?.Resource?.status?.atProvider?.arn,
              _statusAccountId
            ) if (helper._ready(ocds?["k8sCluster"]) and helper._ready(ocds?["karpenterSQS"]) and _statusAccountId) or ocds?["podIdentityRole"] else []

            _instanceProfileName = regex.replace(
              ocds?["karpenterInstanceProfile"]?.Resource?.status?.atProvider?.arn, 
              "arn:aws:iam::\\d+:instance-profile/(.+)", 
              "$1"
            )
            _provCfgK8sName = ocds?["providerConfigKubernetes"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
            _items += [
              _helper_karpenter_node_class(i, ng, _instanceProfileName , _provCfgK8sName) for i, ng in _nodeGroups
            ] if (helper._ready(ocds?["k8sCluster"]) and helper._ready(ocds?["karpenterInstanceProfile"]) and _provCfgK8sName) or ocds?["karpenterNodeClassPublic"] else []

            _items += [
              _helper_karpenter_node_pools(i, ng, _provCfgK8sName) for i, ng in _nodeGroups
            ] if (helper._ready(ocds?["k8sCluster"]) and _provCfgK8sName) or ocds?["karpenterNodePoolPublic0"] else []

            ##### ###### ###### #####

            _providerConfigTypes = ["helm", "kubernetes"]
            _items += [
              _helper_providerCfg(t) \
                for t in _providerConfigTypes \
                  if helper._ready(ocds?["k8sAuth"]) or ocds?["providerConfig{}".format(t.capitalize())]
            ]

            # Object to store kubeconfig file
            _items += [
              k8sv1a2.Object{
                metadata = {
                  annotations = {
                    **helper._set_resource_name("eksKubeconfigSecret"),
                  },
                },
                spec = {
                  deletionPolicy = "Delete"
                  forProvider = {
                    manifest = {
                      apiVersion = "v1",
                      kind = "Secret",
                      metadata = {
                        name = "k8s-eks-{}".format(_oxrName),
                        namespace = _ns,
                        labels = {
                          **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                          "skycluster.io/secret-type" = "k8s-connection-data",
                          "skycluster.io/cluster-name" = _oxrName,
                          "skycluster.io/provider-platform" = "aws"
                        },
                      },
                      "type" = "Opaque",
                      data = {
                        "kubeconfig" = ocds?["k8sAuth"]?.ConnectionDetails?.kubeconfig,
                      }
                    },
                  },
                  providerConfigRef.name = _skyK8SProviderCfgName,
                }
              }
            ] if ocds?["k8sAuth"]?.ConnectionDetails?.kubeconfig or ocds?["eksKubeconfigSecret"] else []


            _nodeGroupNames = [
              "nodeGroup{}{}".format("Public" if ng.publicAccess else "Private", i) \
                for i, ng in _nodeGroups
            ]

            _sshSecGroupIds = [
              ocds?[_n]?.Resource?.status?.atProvider?.resources?[0]?.remoteAccessSecurityGroupId \
                for _n in _nodeGroupNames
            ]

            _udpPortDefaults = [{"fromPort" = port, "toPort" = port} for port in [4500 4800]]

            #
            # SecurityGroupRule
            #
            _items += [
              ec2v1beta1.SecurityGroup{
                metadata = {
                  annotations = {
                    **helper._set_resource_name("sshSecGroup{}".format(_i) ),
                    "crossplane.io/external-name" = _s
                  }
                },
                spec = {
                  managementPolicies = ["Observe"]
                  forProvider = {
                    region = _oxrProvRegion
                  }
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              } for _i, _s in _sshSecGroupIds
            ] if all_true(_sshSecGroupIds) else []

            #
            # SecurityGroupRule
            #
            _items += [
              ec2v1beta1.SecurityGroupRule{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId) 
                  }
                  annotations = {
                    **helper._set_resource_name("secGroupRuleUdp{}-{}-{}".format(_i, port.fromPort, port.toPort)),
                  }
                },
                spec = {
                  forProvider = {
                    region = _oxrProvRegion,
                    securityGroupId = _s
                    protocol = "udp",
                    fromPort = port.fromPort,
                    toPort = port.toPort,
                    type = "ingress",
                    cidrBlocks = [ "0.0.0.0/0" ],
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              } for _i, _s in _sshSecGroupIds for port in _udpPortDefaults 
            ] if all_true(_sshSecGroupIds) else []

            #
            # SecurityGroupRule
            #
            _items += [
              ec2v1beta1.SecurityGroupRule{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                  }
                  annotations = {
                    **helper._set_resource_name("secGroupRule{}".format(_i)),
                  }
                },
                spec = {
                  forProvider = {
                    region = _oxrProvRegion,
                    securityGroupId = _s
                    protocol = "icmp",
                    fromPort = -1,
                    toPort = -1,
                    type = "ingress",
                    cidrBlocks = ["0.0.0.0/0"],
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              } for _i, _s in _sshSecGroupIds
            ] if all_true(_sshSecGroupIds) else []


            extraItems = {
              apiVersion = "meta.krm.kcl.dev/v1alpha1"
              kind = "ExtraResources"
              requirements = {
                "securityGroups" = {
                  apiVersion: "ec2.aws.upbound.io/v1beta1",
                  kind: "SecurityGroup",
                  matchLabels: {
                    "skycluster.io/managed-by": "skycluster",
                    "skycluster.io/provider-platform": "aws",
                    "skycluster.io/provider-region": _oxrProvRegion,
                    "skycluster.io/provider-zone": _oxrProvZone,
                    "skycluster.io/secgroup-type": "default"
                  }
                }
              }
            }

            dxr = {
              **option("params").dxr,
              status = {
                serviceCidr = oxr.spec?.serviceCidr
                podCidr = oxr.spec?.podCidr?.cidr
                # For easier access to cluster:
                if ocds?["eksKubeconfigSecret"]?.Resource?.status?.atProvider?.manifest?.metadata?.name:
                  clusterSecretName = ocds?["eksKubeconfigSecret"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
                if ocds?["k8sCluster"]?.Resource?.metadata?.name:
                  externalClusterName = ocds?["k8sCluster"]?.Resource?.metadata?.name
                controllers = [{publicIp = ocds?["k8sCluster"]?.Resource?.status?.atProvider?.endpoint or Undefined}]
                providerConfigs = {
                  k8s: ocds?["providerConfigKubernetes"]?.Resource?.status?.atProvider?.manifest?.metadata?.name or Undefined
                  helm: ocds?["providerConfigHelm"]?.Resource?.status?.atProvider?.manifest?.metadata?.name or Undefined
                }
                log = json.encode(_xSetup?.status?.keypair) or "empty",
              }
            }

            items =  [*_items, dxr, extraItems]


            #
            ############### Helper Mixins ###############
            #

            _helper_cluster = lambda s {
              eksv1beta2.Cluster {
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    version = "1.33"
                    accessConfig = {
                      authenticationMode = "API_AND_CONFIG_MAP"
                      bootstrapClusterCreatorAdminPermissions = True
                    }
                    kubernetesNetworkConfig = {
                      serviceIpv4Cidr = _oxrServiceCidr
                    }
                    roleArnSelector = {
                      matchControllerRef = True
                      matchLabels = {
                        "skycluster.io/iam-role" = "controlplane"
                      }
                    }
                    vpcConfig = {
                      endpointPrivateAccess = True
                      securityGroupIdSelector = {
                        matchLabels = {
                          **helper._filter_default_labels(oxr.metadata.labels)
                          # May need to create specific security group
                        }
                      }
                      subnetIdSelector = {
                        matchLabels = {
                          "skycluster.io/cluster-name" = _oxrName
                        }
                      }
                    }
                  }
                }
              }
            }

            _helper_providerCfg = lambda t {
              # we use provider-kubernetes to enforce dependency on secrets,
              # often the secret gets deleted and provider config and all other
              # objects remains stall without being deleted or updated.
              k8sv1a2.Object{
                "metadata" = {
                  labels = {"skycluster.io/managed-by" = "skycluster"}
                  annotations = {
                    **helper._set_resource_name("providerConfig{}".format(t.capitalize()))
                  },
                },
                spec = {
                  references = [{
                    dependsOn = {
                      apiVersion = "v1"
                      kind = "Secret"
                      name = "k8s-eks-{}".format(_oxrName)
                      namespace = _ns
                    }
                  }]
                  deletionPolicy = "Delete"
                  forProvider = {
                    manifest = {
                      apiVersion = "{}.crossplane.io/{}".format(t, "v1beta1" if t == "helm" else "v1alpha1"),
                      kind = "ProviderConfig",
                      metadata = {
                        name = "k8s-eks-{}".format(_oxrName),
                        namespace = _ns,
                        labels = {
                          "skycluster.io/managed-by" = "skycluster"
                          "skycluster.io/cluster-name" = _oxrName
                          "skycluster.io/config-type" = "{}-connection-data".format("k8s" if t == "kubernetes" else "helm")
                        },
                      },
                      spec = {
                        credentials = {
                          source = "Secret"
                          secretRef = {
                            name = "k8s-eks-{}".format(_oxrName)
                            namespace = _ns,
                            key = "kubeconfig"
                          }
                        }
                      }
                    },
                  },
                  providerConfigRef.name = _skyK8SProviderCfgName
                }
              }
            }

            _helper_addon_pod_identity = lambda {
              eksv1beta1.Addon{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **helper._set_resource_name("eks-pod-identity-agent-addon"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    addonName = "eks-pod-identity-agent"
                    clusterNameSelector.matchControllerRef = True
                  }
                }
              }
            }

            _helper_addon_cni = lambda {
              eksv1beta1.Addon{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **helper._set_resource_name("vpc-cni-addon"),
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    addonName = "vpc-cni"
                    clusterNameSelector.matchControllerRef = True
                    # see https://github.com/aws/amazon-vpc-cni-k8s/blob/master/README.md for different options
                    configurationValues: '{"env": {"AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG":"false"}}'
                  }
                }
              }
            }

            _helper_addon_csi = lambda {
              eksv1beta1.Addon{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **helper._set_resource_name("aws-ebs-csi-driver-addon"),
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    addonName = "aws-ebs-csi-driver"
                    clusterNameSelector.matchControllerRef = True
                    configurationValues = '{"defaultStorageClass": {"enabled": true}}'
                  }
                }
              }
            }

            _helper_access_policy_assoc = lambda arn {
              eksv1beta1.AccessPolicyAssociation{
                # force recreate when principalArn changes
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **helper._set_resource_name(crypto.sha256("apc{}".format(arn))),
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    accessScope: {
                      type: "cluster"
                    }
                    clusterNameSelector = {
                      matchControllerRef = True
                    }
                    policyArn: "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"
                    principalArnSelector = {
                      matchLabels = {
                        "skycluster.io/access-entry" = "standard"
                      }
                      matchControllerRef = True
                    }
                  }
                }
              }
            }

            _helper_access_entry = lambda arn {
              eksv1beta1.AccessEntry{
                # force recreate when principalArn changes
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/access-entry" = "standard"
                  }
                  annotations = {
                    **helper._set_resource_name(crypto.sha256("accEntry{}".format(arn))),
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    clusterNameSelector = {
                      matchControllerRef = True
                    }
                    type = "STANDARD"
                    principalArn = arn
                  }
                }
              }
            }

            _helper_role = lambda s {
              iamv1beta1.Role {
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/iam-role" = "controlplane"
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    forceDetachPolicies = True
                    managedPolicyArns = [
                      "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
                    ]
                    assumeRolePolicy = json.encode({
                      Version = "2012-10-17",
                      Statement = [
                        {
                          Effect = "Allow",
                          Principal = {
                            Service = ["eks.amazonaws.com"]
                          },
                          Action = ["sts:AssumeRole"]
                        }
                      ]
                    })
                  }
                }
              }
            }

            _helper_ebs_role = lambda {
              _items = []
              _items += [
                eksv1beta1.PodIdentityAssociation {
                  metadata = {
                    labels = {
                      **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    }
                    annotations = {
                      **helper._set_resource_name("ebsCSIDriverPodIdentityAssociation"),
                    }
                  }
                  spec: _defaults | {
                    forProvider = {
                      region = _oxrProvRegion
                      clusterNameSelector.matchControllerRef = True
                      namespace = "kube-system"
                      serviceAccount = "ebs-csi-controller-sa"
                      roleArnSelector = {
                        matchControllerRef = True
                        matchLabels = {
                          role = "ebs-csi-driver"
                        }
                      }
                    }
                  }
                }
              ]
              _items += [
                iamv1beta1.Role {
                  metadata = {
                    labels = {
                      **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                      role = "ebs-csi-driver"
                    }
                    annotations = {
                      **helper._set_resource_name("ebsCSIDriverRole"),
                      **helper._is_paused_label(oxr.metadata.labels)
                    }
                  }
                  spec: _defaults | {
                    forProvider = {
                      forceDetachPolicies = True
                      managedPolicyArns = [
                        "arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy"
                      ]
                      assumeRolePolicy = _helper_ebs_driver_policy
                  }
                }
              }]
              _items
            }

            _helper_cluster_auth = lambda s {
              eksv1beta1.ClusterAuth{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    clusterNameSelector.matchControllerRef = True
                  }
                  writeConnectionSecretToRef = {
                    name = "k8s-eks-auth-{}".format(_oxrName)
                    namespace = _connectionSecretNamespace
                  }
                }
              }
            }

            _helper_launch_template = lambda {
              ec2v1beta1.LaunchTemplate{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **helper._set_resource_name("lnchTemplatePublic"),
                  }
                }
                spec = _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    keyName = _xSetup?.status?.keypair?.id
                    vpcSecurityGroupIds = [sg.Resource?.status?.atProvider?.id for sg in _secGroups]
                  }
                }
              }
            }

            _helper_node_group = lambda i, ng, ltName {
              eksv1beta2.NodeGroup{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/public-subnet" = "true" if ng.publicAccess else "false"
                  }
                  annotations = {
                    **helper._set_resource_name("nodeGroup{}{}".format("Public" if ng.publicAccess else "Private", i)),
                  }
                }
                spec: _defaults | {
                  initProvider = {
                    scalingConfig = {
                      desiredSize = ng.nodeCount or 1
                    }
                  }
                  forProvider = {
                    region = _oxrProvRegion
                    clusterNameSelector.matchControllerRef = True
                    nodeRoleArnSelector = {
                      matchControllerRef = True
                      matchLabels = {
                        "skycluster.io/iam-role" = "nodegroup"
                      }
                    }
                    launchTemplate = {
                      name = ltName
                    }
                    scalingConfig = {
                      minSize = ng.autoScaling?.minSize or 1
                      maxSize = ng.autoScaling?.maxSize or 10
                    }
                    labels = {
                      **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                      **{
                        if _provSettings?.metadata?.labels?["skycluster.io/provider-profile"]:
                          "skycluster.io/provider-profile" = _provSettings.metadata.labels["skycluster.io/provider-profile"]
                        "skycluster.io/public-subnet" = "true"
                        "submariner.io/gateway" = "true"
                      } if ng.publicAccess else {
                        "skycluster.io/public-subnet" = "false"
                      },
                    }
                    instanceTypes = ng.instanceTypes or ["t3.medium"]
                    subnetIdSelector.matchLabels = {
                      "skycluster.io/public-subnet" = "true" if ng.publicAccess else "false"
                      "skycluster.io/cluster-name" = _oxrName
                    }
                  }
                }
              }
            }

            _helper_subnet = lambda i, s {
              ec2v1beta1.Subnet{
                metadata = {
                  labels = {
                    "skycluster.io/public-subnet" = "false" if s.type == "private" else "true",
                    "skycluster.io/cluster-name" = _oxrName
                  }
                  annotations = {
                    **helper._set_resource_name("subnet{}{}".format("Private" if s.type == "private" else "Public", i)),
                  }
                },
                spec = {
                  forProvider = {
                    cidrBlock = s.cidrBlock,
                    region = _oxrProvRegion,
                    availabilityZone = s.zone,
                    vpcIdSelector.matchLabels = {
                      **helper._filter_default_labels(oxr.metadata.labels)
                    }
                    tags = {
                      "skycluster.io/public-subnet" = "false" if s.type == "private" else "true",
                      "skycluster.io/cluster-name" = _oxrName
                    }
                    mapPublicIpOnLaunch = True if s.type == "public" else False,
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              }
            }

            _helper_role_node_group = lambda s {
              iamv1beta1.Role{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/iam-role" = "nodegroup"
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    forceDetachPolicies = True
                    managedPolicyArns = [
                      "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
                      "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
                      "arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy"
                      "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
                    ]
                    assumeRolePolicy = json.encode({
                      Version = "2012-10-17",
                      Statement = [
                        {
                          Effect = "Allow",
                          Principal = {
                            Service = ["ec2.amazonaws.com"]
                          },
                          Action = ["sts:AssumeRole"]
                        }
                      ]
                    })
                  }
                }
              }
            }

            _helper_route_table = lambda t {
              ec2v1beta1.RouteTable{
                metadata = {
                  labels = {
                    "skycluster.io/cluster-name" = _oxrName
                    "skycluster.io/public-route-table" = "true" if t == "public" else "false",
                  }
                  annotations = {
                    **helper._set_resource_name("{}-route-table".format("public" if t == "public" else "private")),
                  }
                },
                spec = {
                  forProvider = {
                    region = _oxrProvRegion,
                    vpcIdSelector.matchLabels = {
                      **helper._filter_default_labels(oxr.metadata.labels)
                    }
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              }
            }

            _helper_route_table_association = lambda t {
              ec2v1beta1.RouteTableAssociation{
                metadata = {
                  labels = {
                    "skycluster.io/cluster-name" = _oxrName
                    "skycluster.io/public-subnet" = "true" if t == "public" else "false",
                  }
                  annotations = {
                    **helper._set_resource_name("{}-route-table-association".format("public" if t == "public" else "private")),
                  }
                },
                spec = {
                  forProvider = {
                    region = _oxrProvRegion,
                    routeTableIdSelector = {
                      matchLabels = {
                        "skycluster.io/cluster-name" = _oxrName
                        "skycluster.io/public-route-table" = "true" if t == "public" else "false",
                      },
                    },
                    subnetIdSelector = {
                      matchLabels = {
                        "skycluster.io/cluster-name" = _oxrName
                        "skycluster.io/public-subnet" = "true" if t == "public" else "false",
                      },
                    },
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              }
            }

            _helper_route = lambda t {
              ec2v1beta1.Route{
                metadata = {
                  labels = {
                    "skycluster.io/cluster-name" = _oxrName
                    "skycluster.io/public-route-table" = "true" if t == "public" else "false",
                  }
                  annotations = {
                    **helper._set_resource_name("{}-route".format("public" if t == "public" else "private")),
                  }
                },
                spec = {
                  forProvider = {
                    destinationCidrBlock = "0.0.0.0/0",
                    region = _oxrProvRegion,
                    routeTableIdSelector = {
                      matchLabels = {
                        "skycluster.io/cluster-name" = _oxrName
                        "skycluster.io/public-route-table" = "true" if t == "public" else "false",
                      },
                    },
                    if t == "public":
                      gatewayIdSelector.matchLabels = {
                        # TODO
                        **helper._filter_default_labels(oxr.metadata.labels)
                      },
                    if t == "private":
                      networkInterfaceIdSelector = {
                        matchLabels = {
                          **helper._filter_default_labels(oxr.metadata.labels)
                          "skycluster.io/interface-id" = "network-interface",
                        },
                      },
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              }
            }

            _helper_karpenter_roles = lambda _id {
              [
                iamv1beta1.Role{
                  metadata = {
                    labels = {
                      role = "karpenter"
                    }
                    annotations = {
                      **helper._set_resource_name("karpenterInstanceNodeRole"),
                    }
                    generateName = "kp-{}-".format(_id)
                  },
                  spec: _defaults | {
                    forProvider = {
                      assumeRolePolicy = json.encode({
                        Version = "2012-10-17",
                        Statement = [
                          {
                            Effect = "Allow",
                            Principal = { Service = ["ec2.amazonaws.com"] },
                            Action = ["sts:AssumeRole"]
                          }
                        ]
                      }),
                      forceDetachPolicies = True
                    },
                    providerConfigRef = {
                      name = _provCfg.metadata.name
                    }
                  }
                }

                # Attach standard policies to the Karpenter node role
                iamv1beta1.RolePolicyAttachment{
                  metadata = {
                    annotations = {
                      **helper._set_resource_name("karpenterNodeRoleEKSPolicy")
                    }
                  },
                  spec = {
                    forProvider = {
                      policyArn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
                      roleSelector = { matchControllerRef = True, matchLabels = { role = "karpenter" } }
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
                iamv1beta1.RolePolicyAttachment{
                  metadata = { annotations = { **helper._set_resource_name("karpenterNodeRoleCNIPolicy") } },
                  spec = {
                    forProvider = {
                      policyArn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
                      roleSelector = { matchControllerRef = True, matchLabels = { role = "karpenter" } }
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
                iamv1beta1.RolePolicyAttachment{
                  metadata = { annotations = { **helper._set_resource_name("karpenterNodeRoleECRPolicy") } },
                  spec = {
                    forProvider = {
                      policyArn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
                      roleSelector = { matchControllerRef = True, matchLabels = { role = "karpenter" } }
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
                iamv1beta1.RolePolicyAttachment{
                  metadata = { annotations = { **helper._set_resource_name("karpenterNodeRoleSSMPolicy") } },
                  spec = {
                    forProvider = {
                      policyArn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
                      roleSelector = { matchControllerRef = True, matchLabels = { role = "karpenter" } }
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
                # InstanceProfile for Karpenter nodes
                iamv1beta1.InstanceProfile{
                  metadata = {
                    annotations = { **helper._set_resource_name("karpenterInstanceProfile") }
                  },
                  spec = {
                    forProvider = {
                      roleSelector = { matchControllerRef = True, matchLabels = { role = "karpenter" } }
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }

                # AccessEntry to allow Karpenter to interact with cluster (uses eks AccessEntry)
                eksv1beta1.AccessEntry{
                  metadata = {
                    annotations = { **helper._set_resource_name("karpenterAccessEntry") }
                  },
                  spec: _defaults | {
                    forProvider = {
                      region = _oxrProvRegion,
                      type = "EC2_LINUX",
                      clusterNameSelector = {
                        matchControllerRef = True,
                      },
                      # principalArnFromRoleSelector will match the role we create above
                      principalArnFromRoleSelector = {
                        matchControllerRef = True,
                        matchLabels = { role = "karpenter" }
                      }
                    }
                  }
                }
              ]
            }

            _helper_karpenter_sqs_cloudwatch = lambda s {
              [
                # SQS Queue for interruption/notifications consumed by Karpenter
                sqsv1beta1.Queue{
                  metadata = {
                    annotations = { **helper._set_resource_name("karpenterSQS") }
                  },
                  spec = {
                    forProvider = {
                      region = _oxrProvRegion,
                      name = "kp-{}-queue".format(s),
                      messageRetentionSeconds = 300
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }

                # CloudWatch Event Rules (Health, Rebalance, State-change, Spot Interrupt)
                cloudwatcheventsv1beta1.Rule{
                  metadata = {
                    annotations = { 
                      **helper._set_resource_name("karpenterRuleHealthEvent"), 
                      "crossplane.io/external-name" = "kp-health-{}".format(s) }
                    labels = {"crossplane.io/composite" = _oxrName, "type" = "HealthEvent"}
                    name = "kp-health-{}".format(s)
                  },
                  spec = {
                    forProvider = {
                      region = _oxrProvRegion,
                      eventBusName = "default",
                      eventPattern = json.encode({ source = ["aws.health"], "detail-type" = ["AWS Health Event"] })
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
                cloudwatcheventsv1beta1.Rule{
                  metadata = {
                    annotations = { 
                      **helper._set_resource_name("karpenterRuleInstanceRebalance"), 
                      "crossplane.io/external-name" = "kp-irb-{}".format(s) }
                    labels = {"crossplane.io/composite" = _oxrName, "type" = "InstanceRebalance"}
                    name = "kp-irb-{}".format(s)
                  },
                  spec = {
                    forProvider = {
                      region = _oxrProvRegion,
                      eventBusName = "default",
                      eventPattern = json.encode({ source = ["aws.ec2"], "detail-type" = ["EC2 Instance Rebalance Recommendation"] })
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
                cloudwatcheventsv1beta1.Rule{
                  metadata = {
                    annotations = { 
                      **helper._set_resource_name("karpenterRuleInstanceStateChange"), 
                      "crossplane.io/external-name" = "kp-isc-{}".format(s) }
                    labels = {"crossplane.io/composite" = _oxrName, "type" = "InstanceStateChange"}
                    name = "kp-isc-{}".format(s)
                  },
                  spec = {
                    forProvider = {
                      region = _oxrProvRegion,
                      eventBusName = "default",
                      eventPattern = json.encode({ source = ["aws.ec2"], "detail-type" = ["EC2 Instance State-change Notification"] })
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
                cloudwatcheventsv1beta1.Rule{
                  metadata = {
                    annotations = { 
                      **helper._set_resource_name("karpenterRuleSpotInterrupt"), 
                      "crossplane.io/external-name" = "kp-si-{}".format(s) }
                    labels = {"crossplane.io/composite" = _oxrName, "type" = "SpotInterrupt"}
                    name = "kp-si-{}".format(s)
                  },
                  spec = {
                    forProvider = {
                      region = _oxrProvRegion,
                      eventBusName = "default",
                      eventPattern = json.encode({ source = ["aws.ec2"], "detail-type" = ["EC2 Spot Instance Interruption Warning"] })
                    },
                    providerConfigRef = { name = _provCfg.metadata.name },
                    deletionPolicy = _defaults.deletionPolicy
                  }
                }
              ]
            }

            _helper_karpenter_pod_identity = lambda _clusterName, _sqsQueueArn, _instanceNodeRoleArn, _accountId {
              [
                iamv1beta1.Role{
                  metadata = {
                    annotations = { **helper._set_resource_name("podIdentityRole") }
                    labels = {
                      role = "pod-identity" 
                    }
                  },
                  spec = _defaults | {
                    forProvider = {
                      inlinePolicy = [
                        {
                          name = "default"
                          policy = json.encode({
                              "Version": "2012-10-17"
                              "Statement": [
                                {
                                  "Sid": "AllowScopedEC2InstanceActions"
                                  "Effect": "Allow"
                                  "Resource": [
                                    "arn:aws:ec2:${_oxrProvRegion}::image/*"
                                    "arn:aws:ec2:${_oxrProvRegion}::snapshot/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:spot-instances-request/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:security-group/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:subnet/*"
                                  ]
                                  "Action": [
                                      "ec2:RunInstances"
                                      "ec2:CreateFleet"
                                  ]
                                }
                                {
                                  "Sid": "AllowScopedEC2LaunchTemplateAccessActions"
                                  "Effect": "Allow"
                                  "Resource": "arn:aws:ec2:${_oxrProvRegion}:*:launch-template/*"
                                  "Action": [
                                    "ec2:RunInstances"
                                    "ec2:CreateFleet"
                                  ]
                                  "Condition": {
                                    "StringEquals": {
                                      "aws:ResourceTag/kubernetes.io/cluster/${_clusterName}": "owned"
                                    }
                                    "StringLike": {
                                      "aws:ResourceTag/karpenter.sh/nodepool": "*"
                                    }
                                  }
                                }
                                {
                                  "Sid": "AllowScopedEC2InstanceActionsWithTags"
                                  "Effect": "Allow"
                                  "Resource": [
                                    "arn:aws:ec2:${_oxrProvRegion}:*:fleet/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:instance/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:volume/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:network-interface/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:launch-template/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:spot-instances-request/*"
                                  ]
                                  "Action": [
                                    "ec2:RunInstances"
                                    "ec2:CreateFleet"
                                    "ec2:CreateLaunchTemplate"
                                  ]
                                  "Condition": {
                                    "StringEquals": {
                                      "aws:RequestTag/kubernetes.io/cluster/${_clusterName}": "owned"
                                      "aws:RequestTag/eks:eks-cluster-name": _clusterName
                                    }
                                    "StringLike": {
                                      "aws:RequestTag/karpenter.sh/nodepool": "*"
                                    }
                                  }
                                }
                                {
                                  "Sid": "AllowScopedResourceCreationTagging"
                                  "Effect": "Allow"
                                  "Resource": [
                                    "arn:aws:ec2:${_oxrProvRegion}:*:fleet/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:instance/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:volume/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:network-interface/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:launch-template/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:spot-instances-request/*"
                                  ]
                                  "Action": "ec2:CreateTags"
                                  "Condition": {
                                    "StringEquals": {
                                      "aws:RequestTag/kubernetes.io/cluster/${_clusterName}": "owned"
                                      "aws:RequestTag/eks:eks-cluster-name": _clusterName
                                      "ec2:CreateAction": [
                                        "RunInstances"
                                        "CreateFleet"
                                        "CreateLaunchTemplate"
                                      ]
                                    }
                                    "StringLike": {
                                      "aws:RequestTag/karpenter.sh/nodepool": "*"
                                    }
                                  }
                                }
                                {
                                  "Sid": "AllowScopedResourceTagging"
                                  "Effect": "Allow"
                                  "Resource": "arn:aws:ec2:${_oxrProvRegion}:*:instance/*"
                                  "Action": "ec2:CreateTags"
                                  "Condition": {
                                    "StringEquals": {
                                      "aws:ResourceTag/kubernetes.io/cluster/${_clusterName}": "owned"
                                    }
                                    "StringLike": {
                                      "aws:ResourceTag/karpenter.sh/nodepool": "*"
                                    }
                                    "StringEqualsIfExists": {
                                      "aws:RequestTag/eks:eks-cluster-name": _clusterName
                                    }
                                    "ForAllValues:StringEquals": {
                                      "aws:TagKeys": [
                                        "eks:eks-cluster-name"
                                        "karpenter.sh/nodeclaim"
                                        "Name"
                                      ]
                                    }
                                  }
                                }
                                {
                                  "Sid": "AllowScopedDeletion"
                                  "Effect": "Allow"
                                  "Resource": [
                                    "arn:aws:ec2:${_oxrProvRegion}:*:instance/*"
                                    "arn:aws:ec2:${_oxrProvRegion}:*:launch-template/*"
                                  ]
                                  "Action": [
                                    "ec2:TerminateInstances"
                                    "ec2:DeleteLaunchTemplate"
                                  ]
                                  "Condition": {
                                    "StringEquals": {
                                      "aws:ResourceTag/kubernetes.io/cluster/${_clusterName}": "owned"
                                    }
                                    "StringLike": {
                                      "aws:ResourceTag/karpenter.sh/nodepool": "*"
                                    }
                                  }
                                }
                                {
                                  "Sid": "AllowRegionalReadActions"
                                  "Effect": "Allow"
                                  "Resource": "*"
                                  "Action": [
                                    "ec2:DescribeAvailabilityZones"
                                    "ec2:DescribeImages"
                                    "ec2:DescribeInstances"
                                    "ec2:DescribeInstanceTypeOfferings"
                                    "ec2:DescribeInstanceTypes"
                                    "ec2:DescribeLaunchTemplates"
                                    "ec2:DescribeSecurityGroups"
                                    "ec2:DescribeSpotPriceHistory"
                                    "ec2:DescribeSubnets"
                                  ]
                                  "Condition": {
                                    "StringEquals": {
                                      "aws:RequestedRegion": _oxrProvRegion
                                    }
                                  }
                                }
                                {
                                  "Sid": "AllowSSMReadActions"
                                  "Effect": "Allow"
                                  "Resource": "arn:aws:ssm:${_oxrProvRegion}::parameter/aws/service/*"
                                  "Action": "ssm:GetParameter"
                                }
                                {
                                  "Sid": "AllowPricingReadActions"
                                  "Effect": "Allow"
                                  "Resource": "*"
                                  "Action": "pricing:GetProducts"
                                }
                                {
                                  "Sid": "AllowInterruptionQueueActions"
                                  "Effect": "Allow"
                                  "Resource": _sqsQueueArn
                                  "Action": [
                                    "sqs:DeleteMessage"
                                    "sqs:GetQueueUrl"
                                    "sqs:ReceiveMessage"
                                  ]
                                }
                                {
                                  "Sid": "AllowPassingInstanceRole"
                                  "Effect": "Allow"
                                  "Resource": _instanceNodeRoleArn
                                  "Action": "iam:PassRole"
                                  "Condition": {
                                    "StringEquals": {
                                      "iam:PassedToService": "ec2.amazonaws.com"
                                    }
                                  }
                                }
                                {
                                  "Sid": "AllowAPIServerEndpointDiscovery"
                                  "Effect": "Allow"
                                  "Resource": "arn:aws:eks:${_oxrProvRegion}:${_accountId}:cluster/${_clusterName}"
                                  "Action": "eks:DescribeCluster"
                                }
                              ]
                            })
                            }
                        ]
                      assumeRolePolicy = _helper_pod_identity_policy
                    }
                  }
                }

                eksv1beta1.PodIdentityAssociation{
                  metadata = {
                    annotations = { **helper._set_resource_name("podIdentityAssociation") }
                  },
                  spec = _defaults | {
                    forProvider = {
                        region = _oxrProvRegion
                        roleArnSelector: {
                          matchControllerRef = True
                          matchLabels = { role = "pod-identity" }
                        }
                        clusterNameSelector = {
                          matchControllerRef = True
                        }
                        serviceAccount = "karpenter"
                        namespace = "karpenter"
                    }
                  }
                }
              ]
            }

            _helper_karpenter_helm = lambda _clusterName, _queueName, helmProvCfgName {
              helmv1b1.Release{
                metadata = {
                  labels = {
                    "skycluster.io/managed-by": "skycluster",
                  },
                  annotations = {
                    **helper._set_resource_name("karpenterChart"),
                    "crossplane.io/external-name" = "karpenter"
                  }
                }
                spec = {
                  forProvider = {
                    chart = {
                      name = "karpenter"
                      repository = "oci://public.ecr.aws/karpenter"
                      version = "1.3.4"
                    }
                    namespace = "karpenter"
                    values = {
                      settings = {
                        clusterName = _clusterName
                        interruptionQueueName = _queueName
                      }
                    }
                    set = [{
                      name = "replicas"
                      value = "1"
                    }]
                  }
                  providerConfigRef = {
                    name = helmProvCfgName
                  }
                }
              }
            }

            _helper_karpenter_node_class = lambda i, ng, _instanceProfileName, _k8sProvCfgName {
              k8sv1a2.Object{
                metadata = {
                  annotations = {
                    **helper._set_resource_name("karpenterNodeClass{}{}".format("Public" if ng.publicAccess else "Private", i))
                  }
                  labels = { "skycluster.io/public-subnet" = "true" if ng.publicAccess else "false" }
                },
                spec = {
                  deletionPolicy = "Orphan"
                  forProvider = {
                    manifest = {
                      apiVersion = "karpenter.k8s.aws/v1",
                      kind = "EC2NodeClass",
                      metadata = { name = "public" if ng.publicAccess else "private" },
                      spec = {
                        amiFamily = "AL2"
                        amiSelectorTerms = [{
                          alias = "al2@latest"
                        }]
                        tags = {
                          if _provSettings?.metadata?.labels?["skycluster.io/provider-profile"]:
                            "skycluster.io/provider-profile" = _provSettings.metadata.labels["skycluster.io/provider-profile"]
                          KarpenterNodePoolName = "public" if ng.publicAccess else "private"
                          # NodeType = "default",
                          # intent = "apps",
                          # "karpenter.sh/discovery" = _clusterName
                        },
                        subnetSelectorTerms = [{
                          tags = {
                            "skycluster.io/public-subnet" = "true" if ng.publicAccess else "false"
                            "skycluster.io/cluster-name" = _oxrName
                          }}
                        ],
                        securityGroupSelectorTerms = [{
                          tags = {
                            **helper._filter_default_labels(oxr.metadata.labels)
                            "skycluster.io/secgroup-type" = "default",
                          }}
                        ],
                        instanceProfile = _instanceProfileName
                        if _xSetup?.status?.keypair?.publicKey:
                          userData = _helper_user_data(_xSetup?.status?.keypair?.publicKey)
                      }
                    }
                  },
                  providerConfigRef = { name = _k8sProvCfgName }
                }
              }
            }

            _helper_karpenter_node_pools = lambda i, ng, _k8sProvCfgName {
              k8sv1a2.Object{
                metadata = {
                  annotations = {
                    **helper._set_resource_name("karpenterNodePool{}{}".format("Public" if ng.publicAccess else "Private", i))
                  }
                  labels = {
                    "skycluster.io/public-subnet" = "true" if ng.publicAccess else "false"
                  }
                },
                spec = {
                  deletionPolicy = "Orphan"
                  forProvider = {
                    manifest = {
                      apiVersion = "karpenter.sh/v1",
                      kind = "NodePool",
                      metadata = { 
                        name = "np-{}-{}".format("public" if ng.publicAccess else "private", i), 
                      },
                      spec = {
                        disruption = {
                          consolidateAfter = "1m",
                          consolidationPolicy = "WhenEmptyOrUnderutilized"
                        },
                        limits = {
                          cpu = 1000,
                          memory = "500Gi"
                        },
                        template = {
                          metadata.labels = {
                            **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                            **{
                              "skycluster.io/public-subnet" = "true"
                              "submariner.io/gateway" = "true"
                            } if ng.publicAccess else {
                              "skycluster.io/public-subnet" = "false"
                            },
                            if _provSettings?.metadata?.labels?["skycluster.io/provider-profile"]:
                              "skycluster.io/provider-profile" = _provSettings.metadata.labels["skycluster.io/provider-profile"]
                          }
                          spec = {
                            nodeClassRef = {
                              group = "karpenter.k8s.aws",
                              kind = "EC2NodeClass",
                              name = "public" if ng.publicAccess else "private"
                            },
                            requirements = [
                              # { key = "karpenter.k8s.aws/instance-category", operator = "In", values = ["c","m","r","i","d"] },
                              # { key = "karpenter.k8s.aws/instance-cpu", operator = "In", values = ["4","8"] },
                              # { key = "karpenter.sh/capacity-type", operator = "In", values = ["spot","on-demand"] },
                              { key = "node.kubernetes.io/instance-type", operator = "In", values = ng.instanceTypes or ["t3.medium"] },
                              { key = "kubernetes.io/arch", operator = "In", values = ["amd64"] }
                            ]
                          }
                        }
                      }
                    }
                  },
                  providerConfigRef = { name = _k8sProvCfgName }
                }
              }
            }

            _helper_ebs_driver_policy = """\
            {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Principal": {
                            "Service": "pods.eks.amazonaws.com"
                        },
                        "Action": [
                            "sts:AssumeRole",
                            "sts:TagSession"
                        ]
                    }
                ]
            }
            """

            _helper_pod_identity_policy = """\
            {
                "Version":"2012-10-17",
                "Statement":[
                    {
                    "Sid":"AllowEksAuthToAssumeRoleForPodIdentity",
                    "Effect":"Allow",
                    "Principal":{
                        "Service":"pods.eks.amazonaws.com"
                    },
                    "Action":[
                        "sts:AssumeRole",
                        "sts:TagSession"
                    ]
                    }
                ]
            }"""

            _helper_user_data = lambda k {
            """\
            #!/bin/bash
            mkdir -p ~ec2-user/.ssh/
            touch ~ec2-user/.ssh/authorized_keys
            cat >> ~ec2-user/.ssh/authorized_keys <<EOF
            {k}
            EOF
            chmod -R go-w ~ec2-user/.ssh/authorized_keys
            chown -R ec2-user ~ec2-user/.ssh    
            """.format(k)
            }
    - step: function-auto-ready
      functionRef:
        name: function-auto-ready

