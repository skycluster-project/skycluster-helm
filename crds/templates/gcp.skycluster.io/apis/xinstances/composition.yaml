apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xinstances.gcp.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: gcp.skycluster.io/v1alpha1
    kind: XInstance
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfigs
              apiVersion: gcp.upbound.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: XSetup
              apiVersion: gcp.skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: gcp
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
                  - key: skycluster.io/provider-zone
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.zone
                  - key: skycluster.io/application-id
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.applicationId
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            provider-gcp = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |2-

            import helper.v1alpha1.main as helper
            import provider_gcp.compute.v1beta1 as gcpv1beta1
            import provider_gcp.compute.v1beta2 as gcpv1beta2

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _skySetup = _extraRes["SkySetups"][0]
            assert _skySetup is not Undefined, "SkySetup must be provided in the extra resources"

            _provCfg = _extraRes["ProviderConfigs"]?[0]
            assert _provCfg is not Undefined, "ProviderConfig must be provided in the extra resources"


            _oxrName = oxr.metadata.name
            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zone
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.providerRef.applicationId or Undefined

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, \
              "Provider region, primary zone, platform must be specified"

            _defaults = {
              deletionPolicy = "Delete"
              providerConfigRef.name = _provCfg.metadata.name
            }

            _openPorts = [
              {"fromPort" = r.fromPort, "toPort" = r.toPort, "protocol" = r.protocol} 
                for r in oxr.spec.securityGroups?.tcpPorts
            ] if oxr.spec.securityGroups?.tcpPorts else []
            _openPorts += [
              {"fromPort" = r.fromPort, "toPort" = r.toPort, "protocol" = r.protocol} 
                for r in oxr.spec.securityGroups?.udpPorts
            ] if oxr.spec.securityGroups?.udpPorts else []

            _items = []

            _instanceAddresses = []
            _instanceAddresses += [
              "{}/32".format(_privateAddress),
            ] if _privateAddress else []
            _instanceAddresses += [
              "{}/32".format(_publicAddress),
            ] if _publicAddress else []


            _items += [gcpv1beta1.Address{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  "skycluster.io/composite-name" = _oxrName,
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("publicAddress"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              },
              spec = {
                forProvider = {
                  region = _oxrProvRegion
                  addressType = "EXTERNAL"
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }] if oxr.spec.publicIp or ocds?["publicAddress"] else []

            _items += [gcpv1beta1.Address{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  "skycluster.io/composite-name" = _oxrName,
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("privateAddress"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              },
              spec = {
                forProvider = {
                  region = _oxrProvRegion
                  addressType = "INTERNAL"
                  subnetworkSelector.matchLabels = {
                    **helper._filter_labels(oxr.metadata.labels, ["provider-platform", "provider-region", "application-id"])
                    "skycluster.io/default-subnet" = "true"
                  }
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }] 


            _items += [gcpv1beta2.Firewall{
              metadata = {
                labels = {
                  **oxr.metadata?.labels
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                  "skycluster.io/composite-name" = _oxrName,
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("firewall"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              },
              spec = {
                forProvider = {
                  allow = [{
                      protocol = p.protocol
                      ports = [str(ss) for pp in p.ports for ss in range(int(pp.fromPort), int(pp.toPort) + 1)],
                    } for p in _openPorts]
                  direction = "INGRESS"
                  networkSelector.matchLabels = {
                    **helper._filter_default_labels(oxr.metadata.labels)
                  }
                  destinationRanges = _instanceAddresses
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            } for port in _openPorts]

            _privateAddress = ocds?["privateAddress"]?.Resource?.status?.atProvider?.address 
            _publicAddress = ocds?["publicAddress"]?.Resource?.status?.atProvider?.address

            _items += [gcpv1beta2.Instance{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  "skycluster.io/composite-name" = _oxrName,
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("instance"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              },
              spec = {
                forProvider = {
                  machineType = oxr.spec.flavor
                  zone = _oxrProvZone, 
                  bootDisk = {
                    initializeParams = {
                      image = oxr?.spec?.image 
                      size = oxr.spec.gateway?.volumeSize or 20,
                      type = oxr.spec.gateway?.volumeType or "pd-standard",
                    },
                  }, 
                  networkInterface = [
                    {
                      networkIp = _privateAddress
                      subnetworkSelector.matchLabels = {
                        **helper._filter_labels(oxr.metadata.labels, ["provider-platform", "provider-region", "application-id"])
                        "skycluster.io/default-subnet" = "true"
                      }
                      accessConfig = [{
                        natIp = _publicAddress 
                      }] if _publicAddress else Undefined
                    }
                  ]
                  metadataStartupScript = ""
                  metadata = {
                    "ssh-keys" = "ubuntu:{}".format(oxr.spec?.publicKey) 
                    "user-data" = oxr.spec.userData
                  }
                  tags = [
                    "instance-{}".format(_oxrName),
                    # To apply defaultrouting to the default node gateway
                    if not oxr.spec.publicIp:
                      "skycluster-internet" # route 0.0.0.0 to gateway
                    else:
                      "skycluster-internal" # only route 10.0.0.0/8 to gateway
                  ]
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }] if _privateAddress and oxr.spec.flavor else []


            dxr = {
              **option("params").dxr,
              status.network = {
                privateIp = _privateAddress or Undefined
                publicIp = _publicAddress or Undefined
              } if _privateAddress or _publicAddress else Undefined,
            }

            items = [*_items, dxr]


    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
