apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xobjects.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: skycluster.io/v1alpha1
    kind: XObject
  mode: Pipeline
  pipeline:
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |
            import helper.v1alpha1.main as helper
            import provider_kubernetes.v1alpha2 as k8sv1a2


            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources

            # ctx = option("params")?.ctx
            # assert ctx is not Undefined, "Context must be provided in the params"

            assert oxr.spec.providerConfigRef?.name is not Undefined, "providerConfigRef name must be provided in the composite resource"
            assert oxr.spec.manifest is not Undefined, "manifest must be provided in the composite resource"

            _items = []
            _items += [_helper_object()]

            _objStatus = ocds?["object"]?.Resource?.status

            dxr = [{
              **option("params").dxr,
              status = {
                if _objStatus and _objStatus.conditions:
                  conditions = [{
                    type = cond.type
                    status = cond.status
                  } for cond in _objStatus?.conditions]
              }
            }] 

            items = _items + dxr


            _helper_object = lambda {
              k8sv1a2.Object{
                metadata = {
                  annotations = {
                    **helper._set_resource_name("object")
                  }
                }
                spec =  {
                  # if changes are made in manifests from upstream, and object controller 
                  # apply another set of changes in conflict with upstream, then an infinite
                  # loop may occur. So we try to set a specific fields only.
                  forProvider.manifest = {
                    apiVersion = oxr.spec.manifest.apiVersion
                    kind = oxr.spec.manifest.kind
                    
                    if oxr.spec.manifest?.metadata?.name:
                      metadata.name = oxr.spec.manifest.metadata.name
                    if oxr.spec.manifest?.metadata?.namespace:
                      metadata.namespace = oxr.spec.manifest.metadata.namespace
                    if oxr.spec.manifest?.metadata?.labels:
                      metadata.labels = oxr.spec.manifest.metadata.labels
                    if oxr.spec.manifest?.metadata?.annotations:
                      metadata.annotations = oxr.spec.manifest.metadata.annotations
                    
                    spec = oxr.spec.manifest?.spec
                    
                    if oxr.spec.manifest?.data: # for ConfigMap, Secret
                      data = oxr.spec.manifest.data
                    
                    if oxr.spec.manifest?.stringData: # for Secret
                      stringData = oxr.spec.manifest.stringData
                    
                    if oxr.spec.manifest?.type: # for Secret
                      type = oxr.spec.manifest.type
                  }
                  providerConfigRef = {
                    name = oxr.spec.providerConfigRef.name
                  }
                  # readiness = {
                  #   celQuery = ""
                  #   policy = "SuccessfulCreate"
                  # }
                }
              }
            }

    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
