apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xmeshistios.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: skycluster.io/v1alpha1
    kind: XMeshIstio
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - apiVersion: kubernetes.crossplane.io/v1alpha1
              kind: ProviderConfig
              into: ClusterK8SProviderConfigs
              type: Selector
              selector:
                minMatch: 0
                maxMatch: 400
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/config-type
                    type: Value
                    value: k8s-connection-data
            - apiVersion: helm.crossplane.io/v1beta1
              kind: ProviderConfig
              into: ClusterHelmProviderConfigs
              type: Selector
              selector:
                minMatch: 0
                maxMatch: 400
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/config-type
                    type: Value
                    value: helm-connection-data
            - kind: XSetup
              into: XSetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                minMatch: 1
                maxMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-helm = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |
            import yaml
            import json
            import base64

            import helper.v1alpha1.main as helper
            import provider_kubernetes.v1alpha2 as k8sv1a2
            import provider_helm.v1beta1 as helmv1b1

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources
            extra = option("params")?.extraResources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _xsetup = _extraRes["XSetups"]?[0] or Undefined
            assert _xsetup is not Undefined, "XSetup resource must be provided in the extra resources"

            # These are secrets containing istio remote secrets for remote clusters
            # They will be generated by the Job later here
            _remoteSecrets = extra["clusterRemoteSecrets"] or Undefined

            _remoteK8SProviderCfgs = _extraRes["ClusterK8SProviderConfigs"] or Undefined
            assert _remoteK8SProviderCfgs is not Undefined, "ClusterK8SProviderConfigs resource must be provided in the extra resources"

            _remoteHelmProviderCfgs = _extraRes["ClusterHelmProviderConfigs"] or Undefined
            assert _remoteHelmProviderCfgs is not Undefined, "ClusterHelmProviderConfigs resource must be provided in the extra resources"

            assert oxr.spec?.localCluster?.podCidr, "Pod CIDR must be provided in the spec"
            assert oxr.spec?.localCluster?.serviceCidr, "Service CIDR must be provided in the spec"

            # Default (local) provider config
            _k8sProvCfgName = _xsetup.status?.providerConfig?.kubernetes?.name or Undefined
            _k8sMgmtClusterName = "skycluster-management"

            _clusterNames = oxr.spec?.clusterNames or []
            assert len(_clusterNames) > 0, "At least one cluster name must be provided in the spec.clusters"

            #
            # fetch referenced xkubes objects based on the cluster names (cloud-provider specific k8s)
            #
            _clusterNamesRef = [o?.Resource?.status?.clusterName for s in _clusterNames for k, obj in extra if k == s for o in obj]
            # since we have the local management cluster as part of the multi-cluster setup
            # we manually add the name of the local management cluster
            _clusterNamesRef += [_k8sMgmtClusterName]

            # construct helper maps for remote-secrets and remote-provider-configs
            _remoteSecretsMap: {str:{str:any}} = {
              cn = {
                  data = s.Resource?.data
                  name = s.Resource?.metadata?.name
                } for cn in _clusterNamesRef for s in _remoteSecrets \
                  if cn == s.Resource?.metadata?.labels?["skycluster.io/cluster-name"]
            } if _remoteSecrets else Undefined

            _remoteK8SKubeconfigs = {
              cn = {
                kubeconfig = p?.Resource?.data?["kubeconfig"]
              } for cn in _clusterNamesRef for p in (extra?["kconfigSecrets"] or []) \
                  if cn == p?.Resource?.metadata?.labels?["skycluster.io/cluster-name"]
            }

            _remoteK8SProviderCfgsMap = {
              cn = p.metadata?.name for cn in _clusterNamesRef for p in _remoteK8SProviderCfgs \
                  if cn == p.metadata?.labels?["skycluster.io/cluster-name"]
            }

            _remoteHelmProviderCfgsMap = {
              cn = p.metadata?.name for cn in _clusterNamesRef for p in _remoteHelmProviderCfgs \
                  if cn == p.metadata?.labels?["skycluster.io/cluster-name"]
            }
            assert len(_remoteK8SProviderCfgsMap) == len(_remoteHelmProviderCfgsMap), \
              "Remote K8S and Helm provider configs must exist for all clusters, found {} K8S and {} Helm configs."\
                .format(len(_remoteK8SProviderCfgsMap), len(_remoteHelmProviderCfgsMap))

            # merge the two
            _remoteProviderCfgsMaps = {
              cn = {
                k8s = _remoteK8SProviderCfgsMap[cn]
                helm = _remoteHelmProviderCfgsMap[cn]
              } for cn in _remoteHelmProviderCfgsMap
            }

            # Retrieve xkubes pod and service cidr
            # will be used in the next step
            _xkubesRefData = {
              o?.Resource?.status?.clusterName = {
                podCidr = o?.Resource?.status?.podCidr
                serviceCidr = o?.Resource?.status?.serviceCidr
                platform = o?.Resource?.spec?.providerRef?.platform
              } for s in _clusterNames for k, obj in extra if k == s for o in obj
            } | {
              # merge with local management cluster's data
              k = {
                podCidr = oxr.spec?.localCluster?.podCidr
                serviceCidr = oxr.spec?.localCluster?.serviceCidr
              } for k in [_k8sMgmtClusterName]
            }

            _items = []

            # # # ################# Istio Setup ###############
            _items += [
              _helper_istio_base(s, _chartIstio["base"]) \
                for s in _clusterNamesRef \
                  if (_remoteProviderCfgsMaps) \
                    or ocds?["istio-base-{}".format(s)]
            ]

            #
            # Istio operator using helm
            #
            _items += [
              _helper_istio_operator(s, _chartIstio["istiod"]) for s in _clusterNamesRef \
                if (_remoteProviderCfgsMaps) \
                  or ocds?["istiod-{}".format(s)]
            ]

            #
            # Create remote secrets, it must be created after base and istio releases
            #   This script uses istioctl to create the necessary certificates
            #   for remote clusters and store all data in <cluster-name>-cacerts secret 
            #   in the local management cluster.
            #   If the secret exists, it will be reused.
            #
            _items += [
              _helper_remote_secret(s) for s in _clusterNamesRef \
                if ocds?["istiod-{}".format(s)]?.Resource?.status?.atProvider?.state == "deployed" and \
                  ocds?["istio-base-{}".format(s)]?.Resource?.status?.atProvider?.state == "deployed" and \
                  _k8sProvCfgName
            ]


            # # ###################### dxr ######################

            dxr = {
              **option("params").dxr,
              status = {
                clusters = [{ 
                  nameRef = s
                  status = ""
                  # providerConfigName = _remoteK8SProviderCfgsMap[s]
                  # if _remoteSecretsMap:
                  #   secretName = _remoteSecretsMap?[s]?.name or Undefined
                } for s in _clusterNamesRef]
                log = json.encode(_xkubesRefData)
              }
            }

            extraItems = {
              apiVersion = "meta.krm.kcl.dev/v1alpha1"
              kind = "ExtraResources"
              requirements = {
                **{s = {
                    apiVersion: "skycluster.io/v1alpha1",
                    kind: "XKube",
                    matchName: s
                  } for s in _clusterNames if s != _k8sMgmtClusterName
                }
                **{"submarinerSecret" = {
                    apiVersion: "v1",
                    kind: "Secret",
                    matchLabels: {
                      "skycluster.io/managed-by": "skycluster",
                      "skycluster.io/config-type": "connection-secret"
                    }
                }}
                **{"kconfigSecrets" = {
                    apiVersion: "v1",
                    kind: "Secret",
                    matchLabels: {
                      "skycluster.io/managed-by": "skycluster",
                      "skycluster.io/secret-type": "k8s-connection-data"
                    }
                }}
                **{"clusterRemoteSecrets" = {
                  apiVersion: "v1",
                  kind: "Secret",
                  matchLabels: {
                    "skycluster.io/managed-by": "skycluster",
                    "skycluster.io/secret-type": "cluster-cacert"
                  }
                }}
              }
            }

            items = [*_items, dxr, extraItems]


            _helper_remote_secret = lambda s {
              k8sv1a2.Object{
                metadata = {
                  labels = {"skycluster.io/pod-type": "istio-remote-secret"}
                  annotations = helper._set_resource_name("remote-secret-{}".format(s))
                }
                spec =  {
                  forProvider.manifest = {
                    apiVersion = "batch/v1"
                    kind = "Job"
                    metadata = { 
                      name = "istio-remote-secret-{}".format(s),
                      namespace = "skycluster-system",
                      labels =  {"skycluster.io/pod-type": "istio-remote-secret"},
                    }
                    spec = {
                      completions = 1
                      backoffLimit = 0
                      template = {
                        metadata = {
                          labels = {
                            "name": "istio-remote-secret-{}".format(s)
                          }
                        }
                        spec = {
                          serviceAccountName: "skycluster-sva"
                          restartPolicy = "Never"
                          volumes = [{
                              name = "work"
                              emptyDir = {}
                            }, {
                              name = "script"
                              configMap = {
                                name = "script-kubemesh-setup"
                                defaultMode = 0755
                              }
                            }
                          ]
                          containers = [{
                              name = "runner"
                              image = "etesami/kubectl:latest"
                              imagePullPolicy = "IfNotPresent"
                              command = ["/bin/bash","-lc","/script/istio-remote-secret.sh"]
                              env = [{
                                  name = "NAMESPACE"
                                  value = "skycluster-system"
                                }, {
                                  name = "CLUSTER_NAME"
                                  value = "{}".format(s)
                                }, {
                                  name = "OWNER"
                                  value = oxr.metadata.name
                                }, {
                                  name = "SCRIPTS_DIR"
                                  value = "/script"
                                }, {
                                  name = "OWNER_PATCH"
                                  value = json.encode({
                                    metadata = {
                                      ownerReferences = [{
                                        apiVersion = "skycluster.io/v1alpha1",
                                        kind = "XKubeMesh",
                                        name = oxr.metadata.name,
                                        uid = oxr.metadata.uid,
                                        controller = True,
                                        blockOwnerDeletion = True
                                      }]
                                    }
                                  })
                                }
                              ]
                              volumeMounts = [{
                                  name = "work"
                                  mountPath = "/work"
                                }, {
                                  name = "script"
                                  mountPath = "/script"
                                }
                              ]
                            }
                          ]
                        }
                      }
                    }
                  }
                  providerConfigRef = {
                    name = _k8sProvCfgName
                  }
                }
              }
            }

            _helper_istio_base = lambda s, ch {
              helmv1b1.Release{
                metadata = {
                  labels = {
                    "skycluster.io/managed-by": "skycluster",
                  },
                  annotations = {
                    **helper._set_resource_name("istio-base-{}".format(s))
                  }
                }
                spec = {
                  forProvider = {
                    chart = {
                      name = ch.name
                      repository = ch.repo
                      version = ch.version
                    }
                    namespace = ch.ns
                    skipCreateNamespace = False
                  }
                  providerConfigRef = {
                    name = _remoteProviderCfgsMaps?[s]?.helm
                  }
                }
              }
            }

            _helper_istio_operator = lambda s, ch {
              helmv1b1.Release{
                metadata = {
                  labels = {
                    "skycluster.io/managed-by": "skycluster",
                  },
                  annotations = {
                    **helper._set_resource_name("istiod-{}".format(s))
                  }
                }
                spec = {
                  forProvider = {
                    chart = {
                      name = ch.name
                      repository = ch.repo
                      version = ch.version
                    }
                    set = [
                      {
                        name = "global.meshID"
                        value = "mesh1"
                      },
                      {
                        name = "global.network"
                        value = "network1"
                      },
                      {
                        name = "global.multiCluster.clusterName"
                        value = s
                      }
                    ]
                    namespace = "istio-system"
                    skipCreateNamespace = False
                  }
                  providerConfigRef = {
                    name = _remoteProviderCfgsMaps?[s]?.helm
                  }
                }
              }
            }

            _chartIstio = {
              n = {
                label = n
                version = "1.27.0"
                repo = "https://istio-release.storage.googleapis.com/charts"
                name = n
                ns = "istio-system"
                prefix_obj = "istio"
                # space-separated K8s object references
                blocking_obj = " ".join(["CustomResourceDefinition/{}".format(s) for s in [
                  "wasmplugins.extensions.istio.io", 
                  "destinationrules.networking.istio.io", 
                  "envoyfilters.networking.istio.io", 
                  "gateways.networking.istio.io", 
                  "proxyconfigs.networking.istio.io", 
                  "serviceentries.networking.istio.io", 
                  "sidecars.networking.istio.io", 
                  "virtualservices.networking.istio.io", 
                  "workloadentries.networking.istio.io",
                  "authorizationpolicies.security.istio.io",
                  "peerauthentications.security.istio.io",
                  "requestauthentications.security.istio.io",
                  "telemetries.telemetry.istio.io"
                ]])
              } for n in ["base", "istiod"]
            }

    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
