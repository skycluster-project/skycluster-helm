apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xinstances.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: skycluster.io/v1alpha1
    kind: XInstance
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                minMatch: 1
                maxMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: ConfigMap
              into: ProviderSettings
              apiVersion: v1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/config-type
                    type: Value
                    value: provider-profile
                  - key: skycluster.io/provider-platform
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.platform
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
            - kind: ConfigMap
              into: InitScripts
              apiVersion: v1
              type: Selector
              selector:
                minMatch: 1
                maxMatch: 100
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/script-type
                    type: Value
                    value: cloud-init
            - kind: Secret
              into: DefaultKeys
              apiVersion: v1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/secret-type
                    type: Value
                    value: default-keypair
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            k8s = "1.32.4"
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-helm = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |-
            import yaml
            import json
            import regex
            import base64
            import helper.v1alpha1.main as helper
            import provider_kubernetes.v1alpha2 as k8sv1a2

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources
            # _dxr = option("params").dxr # desired composite resource
            # dcds = option("params").dcds # desired composed resources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _provSettings = _extraRes["ProviderSettings"]?[0] 
            assert _provSettings is not Undefined, "Provider settings must be provided in the extra resources"

            _skySetup = _extraRes["SkySetups"][0]
            assert _skySetup is not Undefined, "SkySetup must be provided in the extra resources"

            _initScripts = _extraRes["InitScripts"]
            assert _initScripts is not Undefined, "Init scripts must be provided in the extra resources"

            _defaultKey = _extraRes["DefaultKeys"]?[0]
            assert _defaultKey is not Undefined, "DefaultKey must be provided in the extra resources"

            _ns = "skycluster-system"
            _providerK8SCfgName = _skySetup?.status?.providerConfig?.kubernetes?.name

            _oxrProvPlatform = oxr.spec?.providerRef?.platform or Undefined
            _oxrProvRegion = oxr.spec?.providerRef?.region or Undefined
            _oxrProvZone = oxr.spec?.providerRef?.zone or Undefined
            _appId = oxr.spec?.applicationId or Undefined
            assert _oxrProvPlatform and _oxrProvRegion and _oxrProvZone and _appId, \
              "Provider platform, region, and primary zone and application ID must be specified in the providerRef"

            _extractPrivateKey: (any) -> str = lambda data {
              _decstr = base64.decode(data) or Undefined
              _obj = json.decode(_decstr) if _decstr else Undefined
              _decKey = _obj?["privateKey"] if _obj else Undefined
              _key = base64.decode(_decKey) if _decKey else Undefined
              _key or Undefined
            }

            _publicKey = oxr.spec?.publicKey or _skySetup.status?.keypair?.publicKey
            assert _publicKey, "Public key must be specified in the SkySetup status"


            # Supporting both skycluster abstract types and images and provider-native images and types
            _abstractFlavor = regex.match(oxr.spec?.flavor or "2vCPU-4GB", "^\d+vCPU-\d+GB$")
            _abstractImage = regex.match(oxr.spec?.image or "ubuntu-24.04", "^ubuntu-\d+\.\d+$")

            _ami = helper._get_image(_provSettings, oxr.spec?.image or "ubuntu-24.04", _oxrProvZone)?.name \
              if _abstractImage else oxr.spec?.image
            _it = helper._get_instance_type(_provSettings, oxr.spec?.flavor or "2vCPU-4GB", _oxrProvZone)?[0] \
              if _abstractFlavor else oxr.spec?.flavor

            _ud = oxr.spec?.userData or Undefined
            _scripts = ["ip-forwarding", "docker-config"]

            if not oxr.spec?.publicIp:
              _scripts += ["routing-gateway"]
              # we don't have the gateway IP here to perform the replacement
              # using extra resources to load xprovider.skycluster is problematic
              # as it may not have the labels to be filtered.
              # So, we handle this in xinstances.<cloud> composition.

            # Construct the cloud-init userData for running docker container
            if oxr.spec?.dockerSpec:
              _dockerScript = _dockerScriptHeader + oxr.spec?.dockerSpec + _dockerScriptBody
              _cloudInitDockerScript = _helper_cloud_init_scripts(_dockerScript)
              _initScripts = _initScripts + [_cloudInitDockerScript]
              _scripts = _scripts + ["docker-setup"]
              
            _defaultUserData: any = yaml.decode(helper._select_init_scripts(_initScripts, _scripts)) or Undefined
            _userData = helper._append_init_scripts([_defaultUserData] + ([yaml.decode(_ud)] if _ud else []))

            _defaultPrivateKey = _extractPrivateKey(_defaultKey?.data?["config"])

            _items = []
            #
            # xinstances.aws
            #
            _items += [
              {
                apiVersion = "aws.skycluster.io/v1alpha1"
                kind = "XInstance"
                metadata = {
                  labels = helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _appId),
                  annotations = helper._set_resource_name("xinstance")
                }
                spec = {
                  applicationId = _appId
                  flavor = _it
                  preferSpot = oxr.spec?.preferSpot or False
                  image = _ami
                  publicKey = _publicKey
                  publicIp = oxr.spec?.publicIp or False
                  userData = _userData
                  securityGroups = oxr.spec?.securityGroups
                  rootVolumes = oxr.spec?.rootVolumes or [
                    {
                      size = "20"
                      type = "gp2" # TODO: does gpt2 work for all providers?
                    }
                  ]
                  providerRef={
                    platform= _oxrProvPlatform
                    region= _oxrProvRegion
                    zone = _oxrProvZone
                  }
                }
              }
            ] if oxr.spec?.providerRef?.platform == "aws" else []

            #
            # xinstances.gcp
            #
            _items += [
              {
                apiVersion = "gcp.skycluster.io/v1alpha1"
                kind = "XInstance"
                metadata = {
                  labels = helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _appId),
                  annotations = helper._set_resource_name("xinstance")
                }
                spec = {
                  applicationId = _appId
                  flavor = _it
                  preferSpot = oxr.spec?.preferSpot or False
                  image = _ami
                  publicKey = _publicKey
                  publicIp = oxr.spec?.publicIp or False
                  userData = _userData
                  securityGroups = oxr.spec?.securityGroups
                  rootVolumes = oxr.spec?.rootVolumes or [
                    {
                      size = "20"
                      type = "pd-standard" 
                    }
                  ]
                  providerRef={
                    platform= _oxrProvPlatform
                    region= _oxrProvRegion
                    zone = _oxrProvZone
                  }
                }
              }
            ] if oxr.spec?.providerRef?.platform == "gcp" else []

            #
            # xinstances.os
            #
            _items += [
              {
                apiVersion = "os.skycluster.io/v1alpha1"
                kind = "XInstance"
                metadata = {
                  labels = helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _appId),
                  annotations = helper._set_resource_name("xinstance")
                }
                spec = {
                  applicationId = _appId
                  flavor = _it
                  image = _ami
                  publicKey = _publicKey
                  publicIp = oxr.spec?.publicIp or False
                  userData = _userData
                  subnets = oxr.spec?.subnets
                  ipForwarding = oxr.spec?.ipForwarding or False
                  securityGroups = oxr.spec?.securityGroups
                  rootVolumes = oxr.spec?.rootVolumes or []
                  providerRef={
                    platform= _oxrProvPlatform
                    region= _oxrProvRegion
                    zone = _oxrProvZone
                  }
                }
              }
            ] if oxr.spec?.providerRef?.platform == "openstack" else []



            _secretSSHGate = all_true([_privateIp, _defaultPrivateKey, _providerK8SCfgName])
            _items += [k8sv1a2.Object{
              "metadata": {
                labels = helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _appId),
                annotations = {
                  **helper._set_resource_name("secRemoteSSH"),
                },
              },
              spec = {
                forProvider = {
                  manifest = {
                    apiVersion: "v1",
                    kind: "Secret",
                    metadata: {
                      name: "ssh-{}-{}-{}".format(_oxrProvPlatform.lower(), _oxrProvRegion.lower(), _privateIp),
                      namespace: _ns,
                      labels: helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _appId),
                    },
                    type = "Opaque",
                    stringData = {
                      config = json.encode({
                        username = "ubuntu"
                        password = ""
                        hostIP = _privateIp
                        hostPort = "22"
                        privateKey = base64.encode(_defaultPrivateKey)
                      })
                    }
                  },
                }
                providerConfigRef.name = _providerK8SCfgName
              }
            }] if _secretSSHGate or ocds?["sshSecret"] else []

            _sshSecretName = ocds?["secRemoteSSH"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
            _provCfgGate = all_true([_sshSecretName, _providerK8SCfgName])
            _items += [k8sv1a2.Object{
              "metadata" = {
                labels = helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _appId),
                annotations = {
                  **helper._set_resource_name("sshProviderConfig"),
                },
              },
              spec = {
                references = [{
                  # TODO: When object is deleted, the providerconfig remains
                  # Manual deletion of provider config does not remove the finalizer on the secret
                  # The owner of secret still remains waiting for secret to be removed.
                  dependsOn = {
                    apiVersion = "v1"
                    kind = "Secret"
                    name = "ssh-{}-{}-{}".format(_oxrProvPlatform.lower(), _oxrProvRegion.lower(), _privateIp),
                    namespace = _ns
                  }
                }]
                deletionPolicy = "Delete"
                forProvider = {
                  manifest = {
                    apiVersion = "ssh.crossplane.io/v1alpha1",
                    kind = "ProviderConfig",
                    metadata = {
                      name = "ssh-{}-{}-{}".format(_oxrProvPlatform.lower(), _oxrProvRegion.lower(), _privateIp),
                      namespace = _ns,
                      labels = helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _appId),
                    },
                    spec = {
                      credentials = {
                        source = "Secret"
                        secretRef = {
                          name = _sshSecretName
                          namespace = _ns,
                          key = "config"
                        }
                      }
                    }
                  },
                },
                providerConfigRef.name = _providerK8SCfgName
              }
            }] if _provCfgGate or ocds?["sshProviderConfig"] else []


            _sshProviderCfgName = ocds?["sshProviderConfig"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
            _publicIp = ocds?["xinstance"]?.Resource?.status?.network?.publicIp or Undefined
            _privateIp = ocds?["xinstance"]?.Resource?.status?.network?.privateIp or Undefined

            dxr = [{
              **option("params").dxr,
              status = {
                # log = "yes" if oxr.spec?.providerRef?.platform == "aws" else "no"
                providerName = ocds?["xinstance"]?.Resource?.status?.providerName
                if _privateIp or _publicIp:
                  network = {
                    privateIp = _privateIp
                    publicIp = _publicIp
                  }
                if _sshProviderCfgName:
                  providerConfig = {
                    kubernetes.name = _sshProviderCfgName
                  }
                if ocds?["xinstance"]?.Resource?.status?.spotInstance:
                  spotInstance = True
              }
            }]

            items = _items + dxr



            _dockerScriptHeader = """\
            #!/bin/bash
            set -euo pipefail

            """

            _dockerScriptBody = """\

            echo "Waiting for Docker to become ready..." > /root/docker-setup.log
            while ! docker info >/dev/null 2>&1; do
              sleep "$SLEEP"
            done
            echo "Docker is ready." >> /root/docker-setup.log
            echo "Pulling image $IMAGE..." >> /root/docker-setup.log
            docker pull "$IMAGE"

            # Build docker run args
            PORT_ARGS=""
            for p in $PORT_MAPPINGS; do
              PORT_ARGS="$PORT_ARGS -p $p"
            done

            ENV_ARGS=""
            for e in $ENVS; do
              ENV_ARGS="$ENV_ARGS -e $e"
            done

            echo "Running container $NAME (image: $IMAGE)..." >> /root/docker-setup.log
            docker run -d $RESTART $PORT_ARGS $ENV_ARGS --name "$NAME" "$IMAGE"
            echo "Container $NAME started." >> /root/docker-setup.log
            """

            _dockerScriptBase = """\
            write_files:
              - path: /usr/local/bin/run_container.sh
                owner: root:root
                permissions: '0755'
                content: ""
            runcmd:
              - /usr/local/bin/run_container.sh
            """

            _helper_cloud_init_scripts = lambda script {
              {
                "metadata" = {
                  labels = {
                    "skycluster.io/script-init" = "docker-setup"
                  }
                }
                "data" = {
                  "cloud-init": _helper_embed_cloud_init_script(_dockerScriptBase, script)
                }
              }
            }

            _helper_embed_cloud_init_script = lambda ymlData, script {
              yaml.encode({
                "write_files" = [{
                  "path" = "/usr/local/bin/run_container.sh",
                  "owner" = "root:root",
                  "permissions" = "0755",
                  "content" = script,
                }],
                "runcmd"= [ "/usr/local/bin/run_container.sh" ]
              })
            }

    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
