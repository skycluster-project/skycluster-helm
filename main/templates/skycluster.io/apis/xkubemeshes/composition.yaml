apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xkubemeshes.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: skycluster.io/v1alpha1
    kind: XKubeMesh
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - apiVersion: kubernetes.crossplane.io/v1alpha1
              kind: ProviderConfig
              into: ClusterK8SProviderConfigs
              type: Selector
              selector:
                minMatch: 0
                maxMatch: 400
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/config-type
                    type: Value
                    value: k8s-connection-data
            - apiVersion: helm.crossplane.io/v1beta1
              kind: ProviderConfig
              into: ClusterHelmProviderConfigs
              type: Selector
              selector:
                minMatch: 0
                maxMatch: 400
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/config-type
                    type: Value
                    value: helm-connection-data
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            k8s = "1.32.4"
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |2+

            # XKubeMesh orchestrate XKube objects, where each xkube object 
            # is a Kubernetes resource. 
            # 
            # XKube object must create resources that are associated with xkube 
            # at the time of creation. This includes secrets containing kubeconfig,
            # ssh resources required for configuration, etc. 
            #
            # XKubeMesh utilizes each cluster's data, obtained from XKube object
            # to configure inter-cluster coordination.
            #
            # Extra resources:
            #  - Secret (k3s token)
            #  - ProviderConfig (k3s cluster)
            #
            #
            # List of objects:
            #  - XKube (load Xkubes with its Secret containing kubeconfig)
            #  - Object [Job] (Istio CA certificates and remote secrets)
            #  - Object [Secret] Apply remote secrets to each cluster using ProviderConfig
            #  - Helm [istio-base]
            #  - Helm [Submariner] # TODO: this may be happen in the XKube?
            #
            #  Note: clusterName is the name of xkubes.skycluster.io
            #        we need the xkubes.<cloud>.skycluter.io available within status.clusterName
            #
            #  List all xkube clusters (assume names are given by user)
            #
            #  Construct Job to generates certificates and remote secrets for all clusters (it automatically 
            #    fetches the secrets by labels (skycluster.io/secret-type=skycluster-kubeconfig)
            #
            #  Once done successfully (conditional), get all generated secrets (using labels
            #    skycluster.io/secret-type=cluster-cacert, compare label
            #    skycluster.io/cluster-name=<cluster-name>) with the names of xkube objects
            #
            #  Need to fetch providerconfigs.kuberenetes for all xkubes clusters    
            #
            #  Using kubernetes providerconfigs, generates remote secret of each cluster on 
            #  all other clusters.
            #
            #  Creates two map: <cluster-name: []provider-cfgs> and 
            #    <cluster-name>: []remote-secrets and use them below:
            #
            # {
            #   object-kubernetes-secret{
            #     remote_secret_for_s
            #     providercfg_remote_t
            #   } for s in cluster-names for t in cluster-names if s != t 
            # }

            # import yaml
            # import json

            import helper.v1alpha1.main as helper

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources
            extra = option("params")?.extraResources
            # _dxr = option("params").dxr # desired composite resource
            # dcds = option("params").dcds # desired composed resources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _remoteK8SProviderCfgs = _extraRes["ClusterK8SProviderConfigs"] or Undefined
            assert _remoteK8SProviderCfgs is not Undefined, "ClusterK8SProviderConfigs resource must be provided in the extra resources"

            _remoteHelmProviderCfgs = _extraRes["ClusterHelmProviderConfigs"] or Undefined
            assert _remoteHelmProviderCfgs is not Undefined, "ClusterHelmProviderConfigs resource must be provided in the extra resources"

            assert oxr.spec?.localCluster?.podCidr, "Pod CIDR must be provided in the spec"
            assert oxr.spec?.localCluster?.serviceCidr, "Service CIDR must be provided in the spec"

            # Default (local) provider config
            _k8sMgmtClusterName = "skycluster-management"

            _clusterNames = oxr.spec?.clusterNames or []
            assert len(_clusterNames) > 0, "At least one cluster name must be provided in the spec.clusters"

            #
            # fetch referenced xkubes objects based on the cluster names (cloud-provider specific k8s)
            #
            _clusterNamesRef = [o?.Resource?.status?.clusterName for s in _clusterNames for k, obj in extra if k == s for o in obj]
            # since we have the local management cluster as part of the multi-cluster setup
            # we manually add the name of the local management cluster
            _clusterNamesRef += [_k8sMgmtClusterName]

            _remoteK8SProviderCfgsMap = {
              cn = p.metadata?.name for cn in _clusterNamesRef for p in _remoteK8SProviderCfgs \
                  if cn == p.metadata?.labels?["skycluster.io/cluster-name"]
            }

            _remoteHelmProviderCfgsMap = {
              cn = p.metadata?.name for cn in _clusterNamesRef for p in _remoteHelmProviderCfgs \
                  if cn == p.metadata?.labels?["skycluster.io/cluster-name"]
            }
            assert len(_remoteK8SProviderCfgsMap) == len(_remoteHelmProviderCfgsMap), \
              "Remote K8S and Helm provider configs must exist for all clusters, found {} K8S and {} Helm configs."\
                .format(len(_remoteK8SProviderCfgsMap), len(_remoteHelmProviderCfgsMap))

            _items = []

            _items += [
              {
                apiVersion = "skycluster.io/v1alpha1"
                kind = "XMeshSetup"
                metadata = {
                  annotations = {
                    **helper._set_resource_name("meshsetup")
                  }
                }
                spec = {
                  clusterNames = oxr.spec?.clusterNames
                  localCluster = oxr.spec?.localCluster
                }
              }
            ]

            _items += [
              {
                apiVersion = "skycluster.io/v1alpha1"
                kind = "XMeshNet"
                metadata = {
                  annotations = {
                    **helper._set_resource_name("meshnets")
                  }
                }
                spec = {
                  clusterNames = oxr.spec?.clusterNames
                  localCluster = oxr.spec?.localCluster
                }
              }
            ]

            _items += [
              {
                apiVersion = "skycluster.io/v1alpha1"
                kind = "XMeshIstio"
                metadata = {
                  annotations = {
                    **helper._set_resource_name("meshistios")
                  }
                }
                spec = {
                  clusterNames = oxr.spec?.clusterNames
                  localCluster = oxr.spec?.localCluster
                }
              }
            ] if helper._ready(ocds?["meshnets"]) or ocds?["meshistios"] else [] 

            # # ###################### dxr ######################

            dxr = {
              **option("params").dxr,
              status = {
                clusters = [{ 
                  nameRef = s
                  # providerConfigName = _remoteK8SProviderCfgsMap[s]
                } for s in _clusterNamesRef]
              }
            }

            extraItems = {
              apiVersion = "meta.krm.kcl.dev/v1alpha1"
              kind = "ExtraResources"
              requirements = {
                **{s = {
                    apiVersion: "skycluster.io/v1alpha1",
                    kind: "XKube",
                    matchName: s
                  } for s in _clusterNames if s != _k8sMgmtClusterName
                }
                **{"submarinerSecret" = {
                    apiVersion: "v1",
                    kind: "Secret",
                    matchLabels: {
                      "skycluster.io/managed-by": "skycluster",
                      "skycluster.io/config-type": "connection-secret"
                    }
                }}
                **{"kconfigSecrets" = {
                    apiVersion: "v1",
                    kind: "Secret",
                    matchLabels: {
                      "skycluster.io/managed-by": "skycluster",
                      "skycluster.io/secret-type": "k8s-connection-data"
                    }
                }}
              }
            }

            items = [*_items, dxr, extraItems]


    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
