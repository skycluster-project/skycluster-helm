{{ if or .Values.install .Values.test }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-bm-k3s
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: sshtask
    skycluster.io/script-init: bm-k3s-controller
data:
  k3s_controller_prob.sh: |
    #!/bin/bash
    export USERNAME=`whoami`
    export K3S_HOME=/home/$USERNAME/k3s
    export KUBECONFIG=$K3S_HOME/k3s.yaml

    TOKEN=""

    compliant=true
    declare -A details

    if ! sudo kubectl config view --flatten >/dev/null 2>&1; then
      compliant=false
      details["kubectl"]="missing"
    fi


    INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}' || true)
    if [[ -z "$INTF_NAME" ]]; then
      compliant=false
      details["interface"]="cannot-detect"
    else
      IP_ADDR=$(ip -o -4 addr show "$INTF_NAME" | awk '{print $4}' | cut -d/ -f1 || true)
      if [[ -z "$IP_ADDR" ]]; then
        compliant=false
        details["ip_address"]="cannot-detect"
      fi
    fi

    KUBECONFIG=""
    if $compliant; then
      KUBECONFIG=$(sudo kubectl config view --flatten | sed "s/127.0.0.1/$IP_ADDR/" | base64 -w0 || true)
      if [[ -z "$KUBECONFIG" ]]; then
        compliant=false
        details["kubeconfig"]="cannot-generate"
      fi
    fi

    if [[ ! -f "$K3S_HOME/k3s.yaml" ]]; then
      compliant=false
      details["k3s.yaml"]="missing"
    fi

    if [[ ! -f "/var/lib/rancher/k3s/server/node-token" ]]; then
      compliant=false
      details["k3s.token"]="missing"
    else 
      TOKEN=`sudo cat /var/lib/rancher/k3s/server/node-token`
      if [[ -z "$TOKEN" ]]; then
        compliant=false
        details["k3s.token"]="missing"
      fi
    fi

    # build JSON
    checks="{"
      for key in "${!details[@]}"; do
          checks+="\"$key\":\"${details[$key]}\","
      done
    checks="${checks%,}}"

    facts=$(jq -n \
      --arg token "$TOKEN" \
      --arg kube_b64 "$KUBECONFIG" \
      --arg iface "$INTF_NAME" \
      --arg ip "$IP_ADDR" \
      --argjson checks "$checks" \
      '{ 
        network:{interface:$iface, ip:$ip},
        kubeconfig:{encoded:$kube_b64, token:$token},
        checks: $checks
      }'
    )

    jq -n --argjson compliant "$compliant" \
      --argjson facts "$facts" '{compliant: $compliant, facts: $facts}' 

  k3s_controller.sh: |
    #!/bin/bash
          
    export USERNAME=`whoami`
    export K3S_HOME=/home/$USERNAME/k3s
    export KUBECONFIG=$K3S_HOME/k3s.yaml
    export K3S_URL_FILE="https://github.com/k3s-io/k3s/releases/download/v1.33.3+k3s1/k3s"
    export K3S_BIN="/usr/local/bin"

    mkdir -p $K3S_HOME
    mkdir -p $K3S_BIN
    mkdir -p $K3S_HOME/scripts
    mkdir -p $K3S_HOME/logs

    exec > "$K3S_HOME/logs/k3s-install-$(date +'%Y-%m-%d_%H-%M').log" 2>&1

    export INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
    if ! ip -o -4 a show | grep -q $INTF_NAME; then
      echo "Error: interface not found."
      exit 1
    fi
    export NODE_IP=`ip -o -4 a show $INTF_NAME | awk '{print $4}' | cut -d/ -f1`
    export PUBLIC_IP=`curl ifconfig.io`

    ADVERTISE_IP=$PUBLIC_IP
    if [ -z "$PUBLIC_IP" ]; then
      echo "Failed to retrieve public IP. Use node ip instead."
      ADVERTISE_IP=$NODE_IP
    fi

    max_retries=10
    retry_count=0
    install_success=false
    while [ $retry_count -lt $max_retries ]; do
      if curl --max-time 80 -sfL --retry 3 -C - "$K3S_URL_FILE" -o "$K3S_BIN/k3s"; then 
        echo "INFO: Downloaded k3s binary"
        chmod +x "$K3S_BIN/k3s"
        echo "Installing k3s..."
        if curl -sfL https://get.k3s.io | \
          INSTALL_K3S_SKIP_DOWNLOAD=true \
          K3S_KUBECONFIG_MODE="644" \
          INSTALL_K3S_EXEC=" \
            --cluster-cidr __CLUSTER_CIDR__ \
            --advertise-address $ADVERTISE_IP \
            --node-ip $NODE_IP \
            --service-cidr __SERVICE_CIDR__ \
            --flannel-backend=vxlan \
            --disable-network-policy \
            --disable=traefik \
            --node-label skycluster.io/node-type=control-plane \
            --node-label skycluster.io/provider-platform=__PROVIDERPLATFORM__ \
            --node-label skycluster.io/provider-region=__REGION__ \
            --node-label skycluster.io/provider-identifier=__PROVIDERPLATFORM__-__REGION__-__ZONE__ \
            --node-label topology.kubernetes.io/region=__PROVIDERPLATFORM__-__REGION__-__ZONE__ \
            --node-label topology.kubernetes.io/zone=__PROVIDERPLATFORM__-__REGION__-__ZONE__ \
            --node-label submariner.io/gateway=true" sh -; then
          install_success=true
          break
        else
          echo "Attempt $(($retry_count + 1)) of $max_retries failed. Retrying..." 
          retry_count=$(($retry_count + 1))
          sleep 3
        fi
      else
        echo "Downloading k3s Attempt $(($retry_count + 1)) of $max_retries failed. Retrying..."
        retry_count=$(($retry_count + 1))
        sleep 3
      fi
    done
    if [ "$install_success" = false ]; then
      echo "Error: Failed to install k3s after $max_retries attempts." 
      exit 1
    fi
    sudo cp /etc/rancher/k3s/k3s.yaml $K3S_HOME/k3s.yaml
    sudo chown $USERNAME $K3S_HOME/k3s.yaml 

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-bm-setup-gw
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: bm-gw-setup
data:
  env_prepare_static_prob_script.sh: |
    #!/bin/bash
    set -euo pipefail

    PING_CHECK_PATH="/usr/local/bin/ping-check.sh"
    NETWORKD_DISPATCHER_PATH="/etc/networkd-dispatcher/routable.d/50-tailscale"
    CA_CERTIFICATES_PATH="/usr/local/bin/generate-ca-cert.sh"
    ROUTING_IPTABLES_PATH="/usr/local/bin/iptables-postrouting.sh"

    compliant=true    
    declare -A details
    if [[ ! -f "$PING_CHECK_PATH" ]]; then
      compliant=false
      details["ping_check_path"]="missing"
    fi
    if [[ ! -f "$NETWORKD_DISPATCHER_PATH" ]]; then
      compliant=false
      details["networkd_dispatcher_path"]="missing"
    fi
    if [[ ! -f "$CA_CERTIFICATES_PATH" ]]; then
      compliant=false
      details["ca_certificates_path"]="missing"
    fi
    if [[ ! -f "$ROUTING_IPTABLES_PATH" ]]; then
      compliant=false
      details["routing_iptables_path"]="missing"
    fi
    CRON_ENTRY_PING="* * * * * /usr/local/bin/ping-check.sh"
    EXISTING_CRON="$(crontab -l 2>/dev/null || true)"
    if ! echo "$EXISTING_CRON" | grep -Fq "$CRON_ENTRY_PING"; then
      compliant=false
      details["cron_entry_ping"]="missing"
    fi

    # build JSON
    checks="{"
      for key in "${!details[@]}"; do
          checks+="\"$key\":\"${details[$key]}\","
      done
    checks="${checks%,}}"

    facts=$(jq -n \
      --arg ping_check_path "$PING_CHECK_PATH" \
      --arg networkd_dispatcher_path "$NETWORKD_DISPATCHER_PATH" \
      --arg ca_certificates_path "$CA_CERTIFICATES_PATH" \
      --arg routing_iptables_path "$ROUTING_IPTABLES_PATH" \
      --argjson checks "$checks" \
      '{ 
        ping_check_path: $ping_check_path,
        networkd_dispatcher_path: $networkd_dispatcher_path,
        ca_certificates_path: $ca_certificates_path,
        routing_iptables_path: $routing_iptables_path,
        checks: $checks
      }'
    )

    jq -n --argjson compliant "$compliant" --argjson facts "$facts" '{compliant: $compliant, facts: $facts}' 

  # Script to prepare the environment for Tailscale gateway operation.
  env_prepare_static_script.sh: |
    #!/bin/bash
    set -euo pipefail
    LOG_FILE="/root/env-prepare-static.log"
    PING_CHECK_PATH="/usr/local/bin/ping-check.sh"
    NETWORKD_DISPATCHER_PATH="/etc/networkd-dispatcher/routable.d/50-tailscale"
    CA_CERTIFICATES_PATH="/usr/local/bin/generate-ca-cert.sh"
    ROUTING_IPTABLES_PATH="/usr/local/bin/iptables-postrouting.sh"

    create_script_file() {   
      local SCRIPT_PATH="$1"   # first argument: output script path, content from stdin

      echo "Creating $SCRIPT_PATH" >> "$LOG_FILE"
      # Read stdin into the target file
      cat > "$SCRIPT_PATH"

      chmod 0755 "$SCRIPT_PATH"
      echo "Created and made executable: $SCRIPT_PATH" >> "$LOG_FILE"
    }
    add_cron_entry() {
      local CRON_ENTRY="$1"   # the cron line to add

      # Capture existing crontab (ignore error if empty)
      local EXISTING_CRON
      EXISTING_CRON="$(crontab -l 2>/dev/null || true)"

      if ! echo "$EXISTING_CRON" | grep -Fq "$CRON_ENTRY"; then
        echo "Adding cron entry: $CRON_ENTRY" >> "$LOG_FILE"
        (echo "$EXISTING_CRON"; echo "$CRON_ENTRY") | crontab -
      else
        echo "Cron entry already present: $CRON_ENTRY" >> "$LOG_FILE"
      fi
    }

    create_script_file "$PING_CHECK_PATH" <<'EOF'
    #!/bin/bash
    set -euo pipefail
    
    echo "Starting ping check" >> /root/ping-check.log
    ping_ip() {
      local ip="$1"
      nc -z -w2 "$ip" 22
      if [ $? -eq 0 ]; then
        echo "$ip is reachable =)" >> /root/ping-check.log
      else
        nc -z -w1 "$ip" 22
        if [ $? -ne 0 ]; then
          echo "-- $ip IS NOT REACHABLE." >> /root/ping-check.log
        else
          echo "$ip is reachable =)" >> /root/ping-check.log
        fi
      fi
    }

    for ii in `sudo tailscale status | awk '{print $2}' | tail -n +2`; do 
      IP=`sudo tailscale ip --4 $ii` && ping_ip $IP >> /root/ping-check.log; 
    done
    echo "Ping check completed" >> /root/ping-check.log
    EOF

    create_script_file $NETWORKD_DISPATCHER_PATH <<'EOF'
    #!/bin/sh
    INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
    # echo "Configuring interface $INTF_NAME MTU" >> /root/50-tailscale.log
    # ip link set dev "$INTF_NAME" mtu 1450
    echo "Enabling Segmentation Offload" >> /root/50-tailscale.log
    # check out
    # https://tailscale.com/kb/1320/performance-best-practices#linux-optimizations-for-subnet-routers-and-exit-nodes
    if systemctl is-enabled networkd-dispatcher &>/dev/null; then
      echo "networkd-dispatcher is enabled." >> /root/50-tailscale.log
      ethtool -K $INTF_NAME rx-udp-gro-forwarding on rx-gro-list off
    else
      echo "networkd-dispatcher is not enabled. Skipping." >> /root/50-tailscale.log
    fi
    EOF

    create_script_file "$CA_CERTIFICATES_PATH" <<'EOF'
    #!/bin/bash
    echo "Generating CA certificate" >> /root/generate-ca-cert.log

    max_retries=5
    count=0

    until apt-get update -qq && apt-get install -yq ca-certificates jq; do
      count=$((count+1))
      if [ "$count" -ge "$max_retries" ]; then
        echo "Failed to install apt packages after $count attempts" >&2
        exit 1
      fi
      sleep 5
    done

    ENCODED_CA=__CA_CERTIFICATE_ENCODED__
    if [ -z "$ENCODED_CA" ]; then
      echo "CA certificate is not set. Exiting." >> /root/generate-ca-cert.log
      exit 1
    fi
    echo "$ENCODED_CA" | base64 -d > /usr/local/share/ca-certificates/ca-certificate.crt
    if [ $? -ne 0 ]; then
      echo "Failed to decode CA certificate." >> /root/generate-ca-cert.log
      exit 1
    fi
    echo "CA certificate generated successfully." >> /root/generate-ca-cert.log
    # Update the CA certificates
    if ! update-ca-certificates --fresh; then
      echo "Failed to update CA certificates." >> /root/generate-ca-cert.log
      exit 1
    fi
    echo "CA certificates updated successfully." >> /root/generate-ca-cert.log
    EOF

    create_script_file "$ROUTING_IPTABLES_PATH" <<'EOF'
    #!/bin/bash
    echo "Setting iptables rules" >> /root/iptables-postrouting.log
    INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
    IP_ADDR=$(ip -o -4 addr show "$INTF_NAME" | awk '{print $4}' | cut -d/ -f1)
    iptables -tnat -N sky-postrouting 2>/dev/null
    iptables -tnat -C POSTROUTING -j sky-postrouting 2>/dev/null || \
      iptables -tnat -A POSTROUTING -j sky-postrouting
    iptables -tnat -C sky-postrouting -s 100.64.0.0/16 -o "$INTF_NAME" -j MASQUERADE 2>/dev/null || \
      iptables -tnat -A sky-postrouting -s 100.64.0.0/16 -o "$INTF_NAME" -j MASQUERADE
    iptables -tnat -C sky-postrouting -s __SUBNETCIDR__ -o "$INTF_NAME" -j MASQUERADE 2>/dev/null || \
      iptables -tnat -A sky-postrouting -s __SUBNETCIDR__ -o "$INTF_NAME" -j MASQUERADE
    EOF

    $NETWORKD_DISPATCHER_PATH >> /root/50-tailscale.log 2>&1 || true
    $CA_CERTIFICATES_PATH >> /root/generate-ca-cert.log 2>&1 || true
    $ROUTING_IPTABLES_PATH >> /root/iptables-postrouting.log 2>&1 || true
    
    echo "Ensuring cron jobs are present" >> "$LOG_FILE"
    CRON_ENTRY_PING="* * * * * /usr/local/bin/ping-check.sh"
    add_cron_entry "$CRON_ENTRY_PING"

  # Prob script to check for existence of tailscale run script and cron job
  tailscale_run_prob_script.sh: |
    #!/bin/bash
    set -euo pipefail

    TS_RUN_SCRIPT_PATH="/usr/local/bin/tailscale_run.sh"

    compliant=true    
    declare -A details
    if [[ ! -f "$TS_RUN_SCRIPT_PATH" ]]; then
      compliant=false
      details["tailscale_run_script_path"]="missing"
    fi

    CRON_ENTRY_TS="*/5 * * * * /usr/local/bin/tailscale_run.sh"
    EXISTING_CRON="$(crontab -l 2>/dev/null || true)"
    if ! echo "$EXISTING_CRON" | grep -Fq "$CRON_ENTRY_TS"; then
      compliant=false
      details["cron_entry_tailscale_run"]="missing"
    fi

    # build JSON
    checks="{"
      for key in "${!details[@]}"; do
          checks+="\"$key\":\"${details[$key]}\","
      done
    checks="${checks%,}}"

    facts=$(jq -n \
      --arg tailscale_run_script_path "$TS_RUN_SCRIPT_PATH" \
      --argjson checks "$checks" \
      '{ 
        tailscale_run_script_path: $tailscale_run_script_path,
        checks: $checks
      }'
    )

    jq -n --argjson compliant "$compliant" --argjson facts "$facts" '{compliant: $compliant, facts: $facts}' 

  # Tailscale run script, creates a local script to run tailscale up periodically
  # and ensures a cron job exists to run it every 5 minutes.
  tailscale_run_script.sh: |
    #!/bin/bash
    set -euo pipefail
    TS_RUN_SCRIPT_PATH="/usr/local/bin/tailscale_run.sh"
    LOG_FILE="/root/tailscale-run.log"

    create_script_file() {   
      local SCRIPT_PATH="$1"   # first argument: output script path, content from stdin

      echo "Creating $SCRIPT_PATH" >> "$LOG_FILE"
      # Read stdin into the target file
      cat > "$SCRIPT_PATH"

      chmod 0755 "$SCRIPT_PATH"
      echo "Created and made executable: $SCRIPT_PATH" >> "$LOG_FILE"
    }
    add_cron_entry() {
      local CRON_ENTRY="$1"   # the cron line to add

      # Capture existing crontab (ignore error if empty)
      local EXISTING_CRON
      EXISTING_CRON="$(crontab -l 2>/dev/null || true)"

      if ! echo "$EXISTING_CRON" | grep -Fq "$CRON_ENTRY"; then
        echo "Adding cron entry: $CRON_ENTRY" >> "$LOG_FILE"
        (echo "$EXISTING_CRON"; echo "$CRON_ENTRY") | crontab -
      else
        echo "Cron entry already present: $CRON_ENTRY" >> "$LOG_FILE"
      fi
    }

    create_script_file "$TS_RUN_SCRIPT_PATH" <<'EOF'
    #!/bin/bash
    set -euo pipefail
    log() {
      echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ") - $*"
    }

    log "Starting tailscale setup" >> /root/tailscale-setup.log
    # Loop until the tailscale command is available
    if ! command -v tailscale &> /dev/null; then
      log "tailscale not found" >> /root/tailscale-setup.log
      exit 1
    fi
    log "tailscale is available" >> /root/tailscale-setup.log
    LOGIN_URL=__OVERLAY_LOGIN_URL__
    AUTH_KEY=__OVERLAY_TOKEN__
    HOSTNAME=__OVERLAY_HOSTNAME__
    log "Running tailscale" >> /root/tailscale-setup.log
    log "--login-server $LOGIN_URL" >> /root/tailscale-setup.log
    log "--auth-key $AUTH_KEY" >> /root/tailscale-setup.log
    log "--hostname $HOSTNAME" >> /root/tailscale-setup.log

    while true; do
      if tailscale up --login-server $LOGIN_URL --auth-key $AUTH_KEY --hostname $HOSTNAME --advertise-routes __SUBNETCIDR__ --accept-routes; then
        log "Tailscale connected successfully" >> /root/tailscale-setup.log
        break
      else
        service tailscaled restart
        log "Tailscale connection failed, retrying in 10 seconds..." >> /root/tailscale-setup.log
        sleep 5
      fi
    done
    if iptables -tnat -C ts-postrouting -m mark --mark 0x40000/0xff0000 -j MASQUERADE 2>/dev/null; then
      iptables -tnat -D ts-postrouting -m mark --mark 0x40000/0xff0000 -j MASQUERADE
    fi
    log "Tailscale setup completed" >> /root/tailscale-setup.log
    EOF

    echo "Ensuring cron jobs are present" >> "$LOG_FILE"
    CRON_ENTRY_TS="*/5 * * * * /usr/local/bin/tailscale_run.sh"
    add_cron_entry "$CRON_ENTRY_TS"

    # Run once immediately
    $TS_RUN_SCRIPT_PATH >> "$LOG_FILE" 2>&1 || true

  # Script to gather facts about Tailscale installation
  # and determine compliance (installed and running)
  tailscale_installation_prob.sh: |
    #!/bin/bash
    set -euo pipefail

    # Gather facts about Tailscale installation
    installed=false
    version=null
    binary_path=null
    service_active=false

    if command -v tailscale >/dev/null 2>&1; then
      installed=true
    fi

    # Check whether tailscaled (the daemon) is running
    if systemctl >/dev/null 2>&1; then
      if systemctl is-active --quiet tailscaled 2>/dev/null; then
        service_active=true
      fi
    else
      # fallback: check for tailscaled process
      if pgrep -x tailscaled >/dev/null 2>&1; then
        service_active=true
      fi
    fi

    # Define compliance: installed binary present (true) and service is active (optional).
    if [ "$installed" = true ]; then
      compliant=true
    else
      compliant=false
    fi

    # Emit JSON
    cat <<EOF
    {
      "facts": {
        "installed": $installed,
        "service_active": $service_active
      },
      "compliant": $compliant
    }
    EOF
  
  # Script to install Tailscale if not present, ensure setup scripts exist,
  # and ensure crontab entries exist to run setup scripts periodically.  
  tailscale_installation.sh: |
    #!/bin/bash
    set -euo pipefail

    log() {
      echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ") - $*"
    }

    LOG="/root/tailscale-install.log"
    MAX_RETRIES=5
    SLEEP_INTERVAL=5

    log() {
      echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ") - $*"
    }

    # If already installed, exit successfully (idempotent)
    if command -v tailscale >/dev/null 2>&1; then
      log "tailscale already installed"
      exit 0
    fi

    attempt=0
    while : ; do
      attempt=$((attempt + 1))
      log "install attempt #$attempt"

      # Download install script
      if wget -q -O /root/install.sh https://tailscale.com/install.sh; then
        log "download succeeded"
      else
        log "download failed"
      fi

      # run installer non-interactively; capture logs
      DEBIAN_FRONTEND=noninteractive sh /root/install.sh >> "$LOG" 2>&1 || true

      # Check install success
      if command -v tailscale >/dev/null 2>&1; then
        log "installation completed successfully"
        exit 0
      fi

      if [ $attempt -ge $MAX_RETRIES ]; then
        log "installation failed after $attempt attempts"
        exit 1
      fi

      log "installation not yet successful, retrying in $SLEEP_INTERVAL"
      sleep $SLEEP_INTERVAL
    done

    # If installation was successful, run post-install scripts
    if command -v tailscale >/dev/null 2>&1; then
      log "Running post-install scripts"
      if [ -f /usr/local/bin/generate-ca-cert.sh ]; then
        /usr/local/bin/generate-ca-cert.sh >> /root/generate-ca-cert.log 2>&1 || true
      fi
    fi

{{ end }}