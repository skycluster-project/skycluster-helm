apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xsetups.gcp.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: gcp.skycluster.io/v1alpha1
    kind: XSetup
  mode: Pipeline
  pipeline:
    - step: pull-extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfig
              apiVersion: gcp.upbound.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: ConfigMap
              into: ProviderSettings
              apiVersion: v1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/config-type
                    type: Value
                    value: provider-profile
                  - key: skycluster.io/provider-platform
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.platform
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            provider-gcp = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |-
            import helper.v1alpha1.main as helper
            import provider_gcp.compute.v1beta1 as gcpv1beta1
            import provider_gcp.compute.v1beta2 as gcpv1beta2

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources
            # _dxr = option("params").dxr # desired composite resource
            # dcds = option("params").dcds # desired composed resources

            assert oxr.metadata?.labels is not Undefined, "At least one label must be specified"
            assert "skycluster.io/managed-by" in oxr.metadata.labels, "Label 'skycluster.io/managed-by' must be specified"

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _provSettings = _extraRes["ProviderSettings"]?[0] 
            assert _provSettings is not Undefined, "Provider settings must be provided in the extra resources"

            _provCfg = _extraRes["ProviderConfig"][0]
            _skySetup = _extraRes["SkySetups"][0]

            _ns = _skySetup.spec.namespace or "skycluster-system"

            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zones?.primary
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.applicationId or Undefined

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, "Provider region, primary zone, platform must be specified"
            assert len(oxr.spec.subnets) > 0, "At least one subnet must be specified in the XSkyCluster spec"

            assert oxr.spec?.publicKey, "SSH public key must be specified in the XSkyCluster spec"

            _vpcCidr = oxr.spec.vpcCidr
            _vpcCidrParts = _vpcCidr.split("/")
            _vpcCidrIp = _vpcCidrParts[0]
            _vpcCidrOctets = _vpcCidrIp.split(".")
            _vpcCidrFirst = _vpcCidrOctets[0]
            _vpcCidrSecond = _vpcCidrOctets[1]
            _vpcCidrThird = _vpcCidrOctets[2]
            _vpcCidrMask = _vpcCidrParts[1]



            _items = []
            _items += [gcpv1beta1.Network{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("vpc"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              }
              spec = {
                forProvider = {
                  autoCreateSubnetworks = False
                  # mtu = 1460
                  routingMode = "REGIONAL"
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }]

            _subnets = []
            _subnets +=  [{
              "type" = sub.type, # not relevant for GCP
              zone = sub.zone,
              cidrBlock = sub.cidr
            } for i, sub in oxr.spec.subnets]

            _vpcCidr = oxr.spec.vpcCidr

            _items += [gcpv1beta1.Subnetwork{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                   if i == 0:
                    "skycluster.io/default-subnet" = "true"
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("subnet{}{}".format("Private" if s.type == "private" else "Public", i)),
                }
              }
              spec = {
                forProvider = {
                  region = _oxrProvRegion,
                  # if s.default:
                  #   ipCidrRange = s.primaryCidrBlock,
                  #   secondaryIpRange = [
                  #     {
                  #       ipCidrRange = s.podCidrBlock
                  #       rangeName = "pods"
                  #     },
                  #     {
                  #       ipCidrRange = s.serviceCidrBlock
                  #       rangeName = "services"
                  #     }
                  #   ]
                  # else:
                  ipCidrRange = s.cidrBlock,
                  networkSelector.matchControllerRef = True,
                  privateIpGoogleAccess = True,
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            } for i, s in _subnets]

            _items += [gcpv1beta1.Address{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("privateAddress"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              }
              spec = {
                forProvider = {
                  region = _oxrProvRegion,
                  addressType = "INTERNAL",
                  subnetworkSelector.matchControllerRef = True,
                  # prefixLength = int(_vpcCidrMask),
                  # purpose = "VPC_PEERING",
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }]

            _items += [gcpv1beta1.Address{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("publicAddress"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              }
              spec = {
                forProvider = {
                  region = _oxrProvRegion,
                  addressType = "EXTERNAL",
                  # subnetworkSelector.matchControllerRef = True,
                  # prefixLength = int(_vpcCidrMask),
                  # purpose = "VPC_PEERING",
                },
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }]

            _privateAddress = ocds?["privateAddress"]?.Resource?.status?.atProvider?.address
            _publicAddress = ocds?["publicAddress"]?.Resource?.status?.atProvider?.address

            # For 0.0.0.0 to the gatway for nodes without internet access
            _items += [_helper_route_internet("routeInternet")] if ocds?["privateAddress"] or ocds?["routeInternet"] else []
            # For 10.0.0.0/8 to the gateway for internal communication
            _items += [_helper_route_internal("routeInternal")] if ocds?["privateAddress"] or ocds?["routeInternal"] else []


            _tcpPorts = oxr.spec.tcpPorts
            _udpPorts = oxr.spec.udpPorts

            _tcpPortDefaults = [
              # {"fromPort" = 30000, "toPort" = 30050},
              # TODO: this is a very large range for ephemeral ports
              # check if any ports needed here
              {"fromPort" = 30000, "toPort" = 60999},
              {"fromPort" = 15000, "toPort" = 15100} # istio envoy
              # {"fromPort" = 30000, "toPort" = 32767},
              # {"fromPort" = 32768, "toPort" = 60999}, 
            ]
            _tcpPortDefaults = _tcpPortDefaults + [
              {"fromPort" = port, "toPort" = port} 
                for port in [22 80 443 6443 8080 9100 179 4789 5473 2379 10250 10901 10902 8000 8001 9000 9001]
                # 10901 10902 for thanos query
            ]
            _tcpPortsToUse = _tcpPorts if _tcpPorts else _tcpPortDefaults
            _openPorts = [{
              protocol = "tcp"
              ports = _tcpPortsToUse
            }]

            _udpPortDefaults = [
              {"fromPort" = port, "toPort" = port} 
                for port in [3478 4500 4789 4800 8472 41641 51820 51821]
            ]
            _udpPortsToUse = _udpPorts if _udpPorts else _udpPortDefaults
            _openPorts += [{
              protocol = "udp"
              ports = _udpPortsToUse
            }]

            _items += [gcpv1beta1.Firewall{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("firewall"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              }
              spec = {
                forProvider = {
                  allow = [
                    *[
                      {
                        protocol = p.protocol
                        ports = [
                            "{}-{}".format(pp.fromPort, pp.toPort) for pp in p.ports if pp.fromPort != pp.toPort
                          ] + [
                            "{}".format(pp.fromPort) for pp in p.ports if pp.fromPort == pp.toPort
                          ],
                      } for p in _openPorts
                    ], 
                    {"protocol" = "icmp"},
                  ]
                  networkSelector.matchControllerRef = True,
                  sourceRanges = ["0.0.0.0/0"],
                  direction = "INGRESS",
                }
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }]


            _ami = oxr.spec.gateway?.image 
            assert _ami, "Gateway image must be specified in the XSkyCluster spec"

            _it = oxr.spec.gateway?.flavor
            assert _it, "Gateway flavor must be specified in the XSkyCluster spec"


            _userData = oxr.spec.gateway?.userData 
            _userData = _userData.replace("__SUBNETCIDR__", _vpcCidr) if _userData else Undefined

            _items += [gcpv1beta2.Instance{
              metadata = {
                labels = {
                  **oxr.metadata?.labels,
                  **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                }
                annotations = {
                  **oxr.metadata?.annotations,
                  **helper._set_resource_name("instance"),
                  **helper._is_paused_label(oxr.metadata.labels),
                }
              }
              spec = {
                forProvider = {
                  zone = _oxrProvZone,
                  machineType = _it or "e2-standard-4",
                  canIpForward = True,
                  bootDisk = {
                    initializeParams = {
                      image = _ami or "projects/debian-cloud/global/images/family/debian-11",
                      size = oxr.spec.gateway?.volumeSize or 20,
                      type = oxr.spec.gateway?.volumeType or "pd-standard",
                    },
                  },      
                  metadataStartupScript = ""
                  metadata = {
                    "ssh-keys" = "ubuntu:{}".format(oxr.spec?.publicKey) 
                    "user-data" = _userData
                  }
                  networkInterface = [{
                    subnetworkSelector.matchControllerRef = True,
                    networkIp = _privateAddress,
                    accessConfig = [{
                      natIp = _publicAddress
                    }],
                  }]
                }
                providerConfigRef = {
                  name = _provCfg.metadata.name,
                },
              }
            }] if _publicAddress and _privateAddress or ocds?["instance"] else []


            _vpcId = ocds?.vpc?.Resource?.status?.atProvider?.id
            _ocdsSubnets = [v.Resource for k, v in ocds if k.find("subnet") != -1 and v.Resource]

            dxr = {
              **option("params").dxr,
              status = {
                if _vpcId:
                  vpc = {
                    id = _vpcId
                    cidrBlock = _vpcCidr 
                  }
                subnets = [
                  {
                    type = "public" if v.metadata?.labels?["skycluster.io/public-subnet"] and v.metadata?.labels?["skycluster.io/public-subnet"] == "true" else "private"
                    id = v.status?.atProvider?.id
                    cidrBlock = v.status?.atProvider?.cidrBlock or Undefined
                  } for _, v in _ocdsSubnets if v
                ]
                if _publicAddress or _privateAddress:
                  gateway = {
                    publicIp = _publicAddress or Undefined
                    privateIp = _privateAddress or Undefined
                  }
                if _provSettings.metadata?.labels?["skycluster.io/provider-profile"]:
                  providerProfileName = _provSettings.metadata?.labels["skycluster.io/provider-profile"]
              }
            }

            # Collect all resources into a list for output
            items = [*_items, dxr]


            _helper_route_internet = lambda s {
              gcpv1beta1.Route{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name(s),
                  }
                }
                spec = {
                  forProvider = {
                    nextHopIp = _privateAddress
                    networkSelector.matchControllerRef = True,
                    destRange = "0.0.0.0/0",
                    priority = 10
                    tags = ["skycluster-internet"],
                  }
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  }
                }
              }
            }

            _helper_route_internal = lambda s {
              gcpv1beta1.Route{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name(s),
                  }
                }
                spec = {
                  forProvider = {
                    nextHopIp = _privateAddress
                    networkSelector.matchControllerRef = True,
                    destRange = "10.0.0.0/8",
                    priority = 10
                    # This route should be applied to all except to the gateway node
                    tags = ["skycluster-internal"],
                  }
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  }
                }
              }
            }

    - step: crossplane-contrib-function-auto-ready
      functionRef:
        name: function-auto-ready
