apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xkubes.gcp.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: gcp.skycluster.io/v1alpha1
    kind: XKube
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfigs
              apiVersion: gcp.upbound.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: XSetup
              apiVersion: gcp.skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: gcp
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
                  - key: skycluster.io/provider-zone
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.zones.primary
                  - key: skycluster.io/application-id
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.applicationId
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-helm = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-gcp = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |
            import regex as re
            import helper.v1alpha1.main as helper
            import provider_gcp.compute.v1beta1 as gcpv1beta1
            import provider_gcp.cloudplatform.v1beta1 as cp_v1b1
            import provider_gcp.container.v1beta1 as container_v1b1
            import provider_kubernetes.v1alpha1 as k8sv1a1
            import provider_kubernetes.v1alpha2 as k8sv1a2

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources
            # extra = option("params")?.extraResources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _skySetup = _extraRes["SkySetups"][0]
            assert _skySetup is not Undefined, "SkySetup must be provided in the extra resources"
            _skyK8SProviderCfgName = _skySetup.status?.providerConfig?.kubernetes?.name

            _provCfg = _extraRes["ProviderConfigs"]?[0]
            assert _provCfg is not Undefined, "ProviderConfig must be provided in the extra resources"

            _xSetup = _extraRes["XSetup"][0]
            assert _xSetup is not Undefined, "XSetup must be provided in the extra resources"

            _oxrName = oxr.metadata.name
            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zones.primary
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.providerRef.applicationId or Undefined

            # _subnetName = [s.id for s in _xSetup.status.subnets if s.type == "public"]?[0]
            # _subnetName = re.replace(_subnetName, r'^.*/', "") if _subnetName else Undefined

            _ns = "skycluster-system"

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, \
              "Provider region, primary zone, platform must be specified"

            _defaults = {
              deletionPolicy = "Delete"
              providerConfigRef.name = _provCfg.metadata.name
            }


            _items = []

            _items += [
              _helper_svc_acc("svcAcc"),
              _helper_svc_acc_key("svcAccKey"),
            ]

            _svcAccEmail = ocds?["svcAcc"]?.Resource?.status?.atProvider?.email
            _project = ocds?["svcAcc"]?.Resource?.status?.atProvider?.id
            _project = re.replace(_project, r"^projects/", "") if _project else Undefined
            _project = re.replace(_project, r"/serviceAccounts/.*$", "") if _project else Undefined

            _items += [
              _helper_project_iam_member("projectIamMember", _svcAccEmail, _project)
            ] if (_svcAccEmail and _project) or ocds?["projectIamMember"] else []

            _items += [_helper_subnet("subnetEks")]

            # we need to have a default node group spec
            # _defaultNodeGroup = [n for n in oxr.spec.nodeGroups if n?["type"] == "default"]
            # assert len(_defaultNodeGroup) <= 1, "Only one default node group is allowed"
            _defaultNodeCount = 2

            _items += [
              _helper_cluster("gkecluster", _svcAccEmail, _project, _defaultNodeCount)
            ] if (_project and _svcAccEmail and helper._ready(ocds?["subnetEks"])) or ocds?["gkecluster"] else []

            _nodeGroups = oxr.spec.nodeGroups
            _nodeGroupsExists = any_true([ocds?["nodePool{}".format(i)] or False for i, _ in _nodeGroups])
            _items += [
              _helper_node_group(i, ng, _svcAccEmail) for i, ng in _nodeGroups if ng["type"] != "default"
            ] if _svcAccEmail or _nodeGroupsExists else []

            _providerConfigTypes = ["helm", "kubernetes"]
            _items += [
              _helper_providerCfg(t) \
                for t in _providerConfigTypes \
                  if helper._ready(ocds?["gkecluster"]) or ocds?["providerConfig{}".format(t.capitalize())]
            ]

            # _items += [{
            #   apiVersion: "meta.krm.kcl.dev/v1alpha1"
            #   kind: "CompositeConnectionDetails"
            #   data: {
            #     kubeconfig = option("params")?.ocds?["gkecluster"]?.ConnectionDetails?.kubeconfig
            #   } if ocds?["gkecluster"] else {}
            # }]

            # Object to store kubeconfig file
            _kubeconfig = option("params")?.ocds?["gkecluster"]?.ConnectionDetails?.kubeconfig
            _privateKey = option("params")?.ocds?["svcAccKey"]?.ConnectionDetails?.private_key
            _items += [
              _helper_k8s_secret("gkeKubeconfigSecret", _kubeconfig, _privateKey)
            ] if _kubeconfig or ocds?["gkeKubeconfigSecret"] else []

            _k8sProvCfgName = ocds?["providerConfigKubernetes"]?.Resource?.status?.atProvider?.manifest?.metadata?.name 
            _helmProvCfgName = ocds?["providerConfigHelm"]?.Resource?.status?.atProvider?.manifest?.metadata?.name 

            #
            # Workload identity on the GKE
            #
            _items += [
              k8sv1a1.Object{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/composite-name" = _oxrName,
                  }
                  annotations = {
                    **helper._set_resource_name("workloadIdentitySettings"),
                    **helper._is_paused_label(oxr.metadata.labels),
                  }
                  name = "{}-workload-identity-settings".format(_oxrName)
                }
                spec = {
                  deletionPolicy = "Orphan"
                  forProvider = {
                    manifest = {
                      apiVersion = "v1"
                      kind = "ConfigMap"
                      metadata = {
                        name = "{}-workload-identity-settings".format(_oxrName)
                        namespace = "default"
                      }
                      data = {
                        gkeProject = _project
                      }
                    }
                  }
                  providerConfigRef = {
                    name = _k8sProvCfgName
                  }
                }
              } 
            ] if (helper._ready(ocds?["gkecluster"]) and _k8sProvCfgName) or ocds?["workloadIdentitySettings"] else []

            # _defaultSubnetStatus = extra?.defaultSubnet?[0]?.Resource?.status
            # _cidrs = {s.rangeName = s.ipCidrRange for s in _defaultSubnetStatus?.atProvider?.secondaryIpRange}

            dxr = {
              **option("params").dxr,
              status = {
                serviceCidr = ocds?["gkecluster"]?.Resource?.status?.atProvider?.servicesIpv4Cidr or Undefined
                podCidr = ocds?["gkecluster"]?.Resource?.status?.atProvider?.clusterIpv4Cidr or Undefined
                externalClusterName = ocds?["gkecluster"]?.Resource?.metadata?.name or Undefined
                # For easier access to cluster:
                clusterSecretName = ocds?["gkeKubeconfigSecret"]?.Resource?.status?.atProvider?.manifest?.metadata?.name or Undefined
                controllers = [{publicIp = ocds?["gkecluster"]?.Resource?.status?.atProvider?.endpoint or Undefined}] if ocds?["gkecluster"] else []
                providerConfigs = {
                  k8s: ocds?["providerConfigKubernetes"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
                  helm: ocds?["providerConfigHelm"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
                } if ocds?["providerConfigKubernetes"] or ocds?["providerConfigHelm"] else {}
              }
            }

            # extraResources = {
            #   apiVersion: "meta.krm.kcl.dev/v1alpha1"
            #   kind: "ExtraResources"
            #   requirements = {
            #     defaultSubnet = {
            #       apiVersion: "compute.gcp.upbound.io",
            #       kind: "Subnetwork",
            #       matchLabels: {
            #         **helper._filter_labels(oxr.metadata.labels, ["provider-platform", "provider-region", "application-id"]),
            #         "skycluster.io/default-subnet" = "true"
            #       }
            #     }
            #   }
            # }

            items = [*_items, dxr]

            _helper_svc_acc = lambda s {
              cp_v1b1.ServiceAccount{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/composite-name" = _oxrName,
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                  }
                },
                spec = {
                  forProvider = {
                    displayName = _oxrName
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              }
            }

            _helper_svc_acc_key = lambda s {
              cp_v1b1.ServiceAccountKey{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/composite-name" = _oxrName,
                  }
                  annotations = {
                    **helper._set_resource_name("{}".format(s)),
                    **helper._is_paused_label(oxr.metadata.labels),
                  }
                },
                spec = {
                  forProvider = {
                    serviceAccountIdSelector.matchControllerRef = True,
                  },
                  writeConnectionSecretToRef = {
                    name = "k8s-gke-sa-{}".format(_oxrName),
                    # name = "{}-sakey".format(oxr.metadata.uid),
                    namespace = _ns,
                  }
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  }
                }
              }
            }

            _helper_project_iam_member = lambda s, e, p {
              cp_v1b1.ProjectIAMMember{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/composite-name" = _oxrName,
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                    **helper._is_paused_label(oxr.metadata.labels),
                  }
                },
                spec = {
                  forProvider = {
                    role = "roles/container.admin",
                    member = "serviceAccount:{}".format(_svcAccEmail)
                    project = p
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              }
            }

            _helper_cluster = lambda s, e, p, nc {
              container_v1b1.Cluster{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/composite-name" = _oxrName,
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                  }
                },
                spec = {
                  forProvider = {
                    deletionProtection = False,
                    enableIntranodeVisibility = False,
                    initialNodeCount = nc,
                    # defaultSnatStatus = [{disabled = True}],
                    # networkPolicy = [
                    #   {
                    #     enabled = True,
                    #     provider = "CALICO"
                    #   }
                    # ]
                    networkingMode = "ROUTES"
                    clusterIpv4Cidr = oxr.spec.podCidr.cidr
                    # ipAllocationPolicy = [
                    #   {
                    #     # clusterIpv4CidrBlock = oxr.spec.podCidr.cidr
                    #     # servicesIpv4CidrBlock = oxr.spec.serviceCidr
                    #     clusterSecondaryRangeName = "pods",
                    #     servicesSecondaryRangeName = "services",
                    #   }
                    # ]
                    loggingService = "logging.googleapis.com/kubernetes",
                    monitoringService = "monitoring.googleapis.com/kubernetes",
                    location = _oxrProvZone,
                    networkSelector.matchLabels = {
                      **helper._filter_labels(oxr.metadata.labels, ["provider-platform", "provider-region", "application-id"]) 
                      "skycluster.io/managed-by" = "skycluster"
                    }
                    subnetworkSelector.matchLabels = {
                      **helper._filter_labels(oxr.metadata.labels, ["provider-platform", "provider-region", "application-id"]),
                      "skycluster.io/cluster-name" = _oxrName
                    }
                    nodeConfig = [{
                      diskSizeGb = 20,
                      diskType = "pd-standard",
                      imageType = "UBUNTU_CONTAINERD",
                      machineType = "e2-medium" 
                      preemptible = False
                      # This is a public node
                      labels = {
                        "submariner.io/gateway" = "true"
                      }
                      metadata.disableLegacyEndpoints = "true",
                      oauthScopes = [
                        "https://www.googleapis.com/auth/cloud-platform"
                      ],
                      shieldedInstanceConfig: [{
                          enableIntegrityMonitoring = True,
                          enableSecureBoot = True,
                      }]
                      serviceAccount = e,
                      metadata = {
                        "disable-legacy-endpoints" = "true",
                      }
                      tags = [
                        # Nodes route the the subnet range via submariner, that is the range
                        # defined in the subnet primary and secondary range, and service range
                        # However, for the rest of the traffic, i.e. management traffic, we route it
                        # to the gateway node
                        "skycluster-internal" # 10.0.0.0/8 to gateway, priority goes to the sumariner routes
                      ]
                    }]
                    nodeVersion = "1.33.5-gke.1201000"
                    minMasterVersion = "1.33.5-gke.1201000"
                    removeDefaultNodePool = False
                    workloadIdentityConfig = [{
                      workloadPool = "{}.svc.id.goog".format(p) if p else Undefined
                    }]
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                  writeConnectionSecretToRef = {
                    name = "k8s-gke-auth-{}".format(_oxrName),
                    # name = "{}-gkecluster".format(oxr.metadata.uid),
                    namespace = _ns,
                  },
                },
              }
            }

            _helper_node_group = lambda i, ng, e {
              container_v1b1.NodePool{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/composite-name" = _oxrName,
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("nodePool{}".format(i)),
                    **helper._is_paused_label(oxr.metadata.labels),
                  }
                },
                spec = {
                  forProvider = {
                    location = _oxrProvZone,
                    autoscaling = [
                      {
                        totalMinNodeCount = ng.autoscaling?.minSize or 1,
                        totalMaxNodeCount = ng.autoscaling?.maxSize or 100,
                      }
                    ]
                    clusterSelector.matchControllerRef = True
                    if ng.nodeCount:
                      initialNodeCount = ng.nodeCount
                    management = [
                      {
                        autoRepair = True,
                        autoUpgrade = True,
                      }
                    ]
                    if not ng.publicAccess:
                      networkConfig = [
                        {enablePrivateNodes = True}
                      ]
                    # maxPodsPerNode = 55 # not available for route-based clusters
                    nodeConfig = [
                      {
                        diskSizeGb = 20,
                        diskType = "pd-standard",
                        imageType = "UBUNTU_CONTAINERD",
                        machineType = it,
                        labels = {
                          if ng.publicAccess:
                            "submariner.io/gateway" = "true"
                          if _xSetup.status?.providerProfileName:
                            "skycluster.io/provider-profile" = _xSetup.status?.providerProfileName
                        }
                          
                        metadata.disableLegacyEndpoints = "true",
                        oauthScopes = [
                          "https://www.googleapis.com/auth/cloud-platform"
                        ],
                        spot = True,
                        shieldedInstanceConfig: [
                          {
                            enableIntegrityMonitoring = True,
                            enableSecureBoot = True,
                          }
                        ]
                        serviceAccount = e,
                        metadata = {
                          "disable-legacy-endpoints" = "true",
                        }
                        tags = [
                        if not ng.publicAccess:
                          "skycluster-internet" # route 0.0.0.0 to gateway
                        # else:
                        #   "skycluster-internal" # only route 10.0.0.0/8 to gateway
                        ]
                      } for it in ng.instanceTypes
                    ]
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                },
              }
            }

            _helper_subnet = lambda s {
              gcpv1beta1.Subnetwork{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/cluster-name" = _oxrName
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                  }
                }
                spec = {
                  forProvider = {
                    region = _oxrProvRegion,
                    # ipCidrRange = oxr.spec.podCidr.base
                    ipCidrRange = oxr.spec.nodeCidr,
                    # secondaryIpRange = [
                    #   {
                    #     ipCidrRange = oxr.spec.podCidr.cidr
                    #     rangeName = "pods"
                    #   },
                    #   {
                    #     ipCidrRange = oxr.spec.serviceCidr
                    #     rangeName = "services"
                    #   }
                    # ]
                    networkSelector.matchLabels = {
                      **helper._filter_default_labels(oxr.metadata.labels)
                    }
                    privateIpGoogleAccess = True,
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              }
            }

            _helper_k8s_secret = lambda s, kubeconf, pk {
              k8sv1a2.Object{
                metadata = {
                  labels = {
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **helper._set_resource_name(s),
                  },
                },
                spec = {
                  deletionPolicy = "Delete"
                  forProvider = {
                    manifest = {
                      apiVersion = "v1",
                      kind = "Secret",
                      metadata = {
                        name = "k8s-gke-{}".format(_oxrName),
                        namespace = _ns,
                        labels = {
                          **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                          "skycluster.io/secret-type" = "k8s-connection-data",
                          "skycluster.io/cluster-name" = _oxrName,
                          "skycluster.io/provider-platform" = "gcp"
                        },
                        annotations = {
                          **oxr.metadata?.annotations,
                        },
                      },
                      "type" = "Opaque",
                      data = {
                        "kubeconfig" = kubeconf
                        "privateKey" = pk
                      }
                    },
                  },
                  providerConfigRef.name = _skyK8SProviderCfgName,
                }
              }
            }

            _helper_providerCfg = lambda t {
              # we use provider-kubernetes to enforce dependency on secrets,
              # often the secret gets deleted and provider config and all other
              # objects remains stall without being deleted or updated.
              k8sv1a2.Object{
                "metadata" = {
                  labels = {"skycluster.io/managed-by" = "skycluster"}
                  annotations = {
                    **helper._set_resource_name("providerConfig{}".format(t.capitalize()))
                  },
                },
                spec = {
                  references = [{
                    dependsOn = {
                      apiVersion = "v1"
                      kind = "Secret"
                      name = "k8s-gke-{}".format(_oxrName)
                      namespace = _ns
                    }
                  }, {
                    dependsOn = {
                      apiVersion = "v1"
                      kind = "Secret"
                      name = "k8s-gke-sa-{}".format(_oxrName),
                      namespace = _ns
                    }
                  }]
                  deletionPolicy = "Delete"
                  forProvider = {
                    manifest = {
                      apiVersion = "{}.crossplane.io/{}".format(t, "v1beta1" if t == "helm" else "v1alpha1"),
                      kind = "ProviderConfig",
                      metadata = {
                        name = "k8s-gke-{}".format(_oxrName),
                        namespace = _ns,
                        labels = {
                          "skycluster.io/managed-by" = "skycluster"
                          "skycluster.io/cluster-name" = _oxrName
                          "skycluster.io/config-type" = "{}-connection-data".format("k8s" if t == "kubernetes" else "helm")
                        },
                      },
                      spec = {
                        credentials = {
                          source = "Secret"
                          type = "GoogleApplicationCredentials"
                          secretRef = {
                            name = "k8s-gke-{}".format(_oxrName)
                            namespace = _ns,
                            key = "kubeconfig"
                          }
                        }
                        identity = {
                          secretRef = {
                            name = "k8s-gke-sa-{}".format(_oxrName),
                            namespace = _ns
                            key = "private_key"
                          }
                          source = "Secret"
                          type = "GoogleApplicationCredentials"
                        }
                      }
                    },
                  },
                  providerConfigRef.name = _skyK8SProviderCfgName
                }
              }
            }
    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
