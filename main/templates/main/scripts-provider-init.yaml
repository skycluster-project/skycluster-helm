{{ if or .Values.install .Values.test }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-networkd-dispatcher
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: networkd-dispatcher
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /etc/networkd-dispatcher/routable.d/50-tailscale
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/sh
          INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
          echo "Enabling Segmentation Offload" >> /root/50-tailscale.log
          # check out
          # https://tailscale.com/kb/1320/performance-best-practices#linux-optimizations-for-subnet-routers-and-exit-nodes
          if systemctl is-enabled networkd-dispatcher &>/dev/null; then
            echo "networkd-dispatcher is enabled." >> /root/50-tailscale.log
            ethtool -K $INTF_NAME rx-udp-gro-forwarding on rx-gro-list off
          else
            echo "networkd-dispatcher is not enabled. Skipping." >> /root/50-tailscale.log
          fi
    runcmd:
      - /etc/networkd-dispatcher/routable.d/50-tailscale
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-ca-certificate
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: ca-certificate
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /usr/local/bin/generate-ca-cert.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          echo "Generating CA certificate" >> /root/generate-ca-cert.log

          max_retries=5
          count=0

          until apt-get update -qq && apt-get install -yq ca-certificates jq; do
            count=$((count+1))
            if [ "$count" -ge "$max_retries" ]; then
              echo "Failed to install apt packages after $count attempts" >&2
              exit 1
            fi
            sleep 5
          done

          ENCODED_CA=__CA_CERTIFICATE_ENCODED__
          if [ -z "$ENCODED_CA" ]; then
            echo "CA certificate is not set. Exiting." >> /root/generate-ca-cert.log
            exit 1
          fi
          echo "$ENCODED_CA" | base64 -d > /usr/local/share/ca-certificates/ca-certificate.crt
          if [ $? -ne 0 ]; then
            echo "Failed to decode CA certificate." >> /root/generate-ca-cert.log
            exit 1
          fi
          echo "CA certificate generated successfully." >> /root/generate-ca-cert.log
          # Update the CA certificates
          if ! update-ca-certificates --fresh; then
            echo "Failed to update CA certificates." >> /root/generate-ca-cert.log
            exit 1
          fi
          echo "CA certificates updated successfully." >> /root/generate-ca-cert.log
    runcmd:
      - /usr/local/bin/generate-ca-cert.sh
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-iptables-postrouting
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: iptables-postrouting
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /usr/local/bin/iptables-postrouting.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          echo "Setting iptables rules" >> /root/iptables-postrouting.log

          max_retries=5
          count=0
          until apt-get update -qq && apt-get install -yq vim cron; do
            count=$((count+1))
            if [ "$count" -ge "$max_retries" ]; then
              echo "Failed to install apt packages after $count attempts" >&2
              exit 1
            fi
            sleep 3
          done

          INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
          IP_ADDR=$(ip -o -4 addr show "$INTF_NAME" | awk '{print $4}' | cut -d/ -f1)

          MAX_RETRIES=10
          for i in $(seq 1 $MAX_RETRIES); do
            {
              # Create chain if not exists
              iptables -t nat -L sky-postrouting &>/dev/null || iptables -t nat -N sky-postrouting

              iptables -t nat -C POSTROUTING -j sky-postrouting 2>/dev/null || \
                iptables -t nat -A POSTROUTING -j sky-postrouting

              # Add masquerade rules if missing
              iptables -t nat -C sky-postrouting -s 100.64.0.0/16 -o "$INTF_NAME" -j MASQUERADE 2>/dev/null || \
                iptables -t nat -A sky-postrouting -s 100.64.0.0/16 -o "$INTF_NAME" -j MASQUERADE
              
              iptables -t nat -C sky-postrouting -s __SUBNETCIDR__ -o "$INTF_NAME" -j MASQUERADE 2>/dev/null || \
                iptables -t nat -A sky-postrouting -s __SUBNETCIDR__ -o "$INTF_NAME" -j MASQUERADE

            } && break
            echo "Attempt $i failed, retrying in 3s..." >> /root/iptables-postrouting.log
            sleep 3
          done
    runcmd:
      - /usr/local/bin/iptables-postrouting.sh
      - |
        if ! crontab -u root -l 2>/dev/null | grep -Fq '/usr/local/bin/iptables-postrouting.sh'; then
          (crontab -u root -l 2>/dev/null; echo "*/5 * * * * /usr/local/bin/iptables-postrouting.sh") | crontab -u root -
        fi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-tailscale
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: tailscale
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /usr/local/bin/install-tailscale.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          echo "I've been run" >> /root/tailscale-install.log

          max_retries=5
          count=0
          until apt-get update -qq && apt-get install -yq vim cron; do
            count=$((count+1))
            if [ "$count" -ge "$max_retries" ]; then
              echo "Failed to install apt packages after $count attempts" >&2
              exit 1
            fi
            sleep 3
          done

          # Function to install Tailscale
          install_tailscale() {
            wget -q -P /root https://tailscale.com/install.sh
            if [ $? -eq 0 ]; then
              echo "Download succeeded" >> /root/tailscale-install.log
              DEBIAN_FRONTEND=noninteractive apt-get update
              sh /root/install.sh >> /root/tailscale-install.log 2>&1
              return $?
            else
              echo "Download failed" >> /root/tailscale-install.log
              return 1
            fi
          }
          # Loop until the installation succeeds
          until install_tailscale; do
            echo "Installation failed, retrying..." >> /root/tailscale-install.log
            sleep 5 # Wait for 5 seconds before retrying
          done
          echo "Installation Completed" >> /root/tailscale-install.log
      - path: /usr/local/bin/setup-tailscale.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          echo $(date) >> /root/tailscale-setup.log
          # Loop until the tailscale command is available
          while ! command -v tailscale &> /dev/null; do
              echo "tailscale not found, retrying in 5 seconds..." >> /root/tailscale-setup.log
              sleep 5
          done
          echo "tailscale is available" >> /root/tailscale-setup.log
          LOGIN_URL=__OVERLAY_LOGIN_URL__
          AUTH_KEY=__OVERLAY_TOKEN__
          HOSTNAME=__OVERLAY_HOSTNAME__
          echo "Running tailscale" >> /root/tailscale-setup.log
          echo "--login-server $LOGIN_URL" >> /root/tailscale-setup.log
          echo "--auth-key $AUTH_KEY" >> /root/tailscale-setup.log
          echo "--hostname $HOSTNAME" >> /root/tailscale-setup.log
          
          while true; do
            if tailscale up --login-server $LOGIN_URL --auth-key $AUTH_KEY --hostname $HOSTNAME --advertise-routes __SUBNETCIDR__ --accept-routes; then
              echo "Tailscale connected successfully" >> /root/tailscale-setup.log
              break
            else
              service tailscaled restart
              echo "Tailscale connection failed, retrying in 10 seconds..." >> /root/tailscale-setup.log
              sleep 5
            fi
          done
          if iptables -tnat -C ts-postrouting -m mark --mark 0x40000/0xff0000 -j MASQUERADE 2>/dev/null; then
            iptables -tnat -D ts-postrouting -m mark --mark 0x40000/0xff0000 -j MASQUERADE
          fi
          echo $(date) >> /root/tailscale-setup.log
      - path: /usr/local/bin/ping-check.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          echo $(date) >> /root/ping-check.log

          ping_ip() {
            local ip="$1"
            nc -z -w2 "$ip" 22
            if [ $? -eq 0 ]; then
              echo "$ip is reachable =)"
            else
              nc -z -w1 "$ip" 22
              if [ $? -ne 0 ]; then
                echo "-- $ip IS NOT REACHABLE."
              else
                echo "$ip is reachable =)"
              fi
            fi
          }

          for ii in `sudo tailscale status | awk '{print $2}' | tail -n +2`; do 
            IP=`sudo tailscale ip --4 $ii` && ping_ip $IP >> /root/ping-check.log; 
          done
    runcmd:
      - /usr/local/bin/install-tailscale.sh
      - /usr/local/bin/setup-tailscale.sh
      - |
        if ! crontab -u root -l 2>/dev/null | grep -Fq '/usr/local/bin/setup-tailscale.sh'; then
          (crontab -u root -l 2>/dev/null; echo "*/5 * * * * /usr/local/bin/setup-tailscale.sh") | crontab -u root -
        fi
        if ! crontab -u root -l 2>/dev/null | grep -Fq '/usr/local/bin/ping-check.sh'; then
          (crontab -u root -l 2>/dev/null; echo "* * * * * /usr/local/bin/ping-check.sh") | crontab -u root -
        fi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-docker-runtime
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: docker-runtime-config
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /usr/local/bin/install-docker-runtime.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          set -eux

          curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg &&
            curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list |
            sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' |
              sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list

          sudo apt-get update
          sudo apt-get install -y nvidia-container-toolkit

          # if there's an empty /etc/docker/daemon.json, `nvidia-ctk runtime configure --runtime=docker` will fail
          if [ -f /etc/docker/daemon.json ] && [ ! -s /etc/docker/daemon.json ]; then
            sudo rm /etc/docker/daemon.json
          fi

          sudo nvidia-ctk runtime configure --runtime=docker
          sudo systemctl restart docker

          # Validate
          if sudo docker info -f "{{.Runtimes}}" | grep "nvidia-container-runtime"; then
              echo "Successfully installed NVIDIA container runtime"
          else
            echo "Failed to install NVIDIA container runtime"
          fi

    runcmd:
      - /usr/local/bin/install-docker-runtime.sh
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-docker-config
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: docker-config
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /usr/local/bin/install-docker.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          set -eux

          # Update
          apt-get update -y

          # Install dependencies
          apt-get install -y ca-certificates curl gnupg lsb-release

          install -m 0755 -d /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
          chmod a+r /etc/apt/keyrings/docker.asc

          # Add Docker APT repository
          echo \
            "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
            $(. /etc/os-release && echo $VERSION_CODENAME) stable" \
            > /etc/apt/sources.list.d/docker.list

          apt-get update -y && \
            apt-get install -y \
              docker-ce \
              docker-ce-cli \
              containerd.io \
              docker-buildx-plugin \
              docker-compose-plugin

          # Enable and start Docker
          systemctl enable --now docker

          # Optional: add your default user to docker group
          if id ubuntu >/dev/null 2>&1; then
            usermod -aG docker ubuntu
          fi

    runcmd:
      - /usr/local/bin/install-docker.sh
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-bird-config
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: bird-config
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /etc/bird/bird.conf
        owner: root:root
        permissions: '644'
        content: |
          log syslog all;
          log "/var/log/bird.log" { debug, trace, info, remote, warning, error, auth, fatal, bug };
          debug protocols all;
          define my_asn = __AS_NUMBER__;
          define my_addr = __IP_ADDRESS__;
          protocol device {
          }
          protocol direct {
            disabled;	
            ipv4;			
            ipv6;			
          }
          protocol kernel {
            ipv4 {	
                  export all;	
            };
          }
          protocol kernel {
            ipv6 { export all; };
          }
          protocol static {
            ipv4;
          }
          protocol bgp uplink1 {
            description "Regional BGP uplink";
            local my_addr as my_asn;
            direct;
            neighbor range __SUBNETCIDR__ internal;
            ipv4 {
              import all;
            };
          }
      - path: /usr/local/bin/setup-bgp.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          echo "Enabling BGP" >> /root/bgp-setup.log
          mkdir -p /var/log
          touch /var/log/bird.log && chmod 666 /var/log/bird.log
          INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
          ip route add __POD_SUBNET_CIDR__ dev $INTF_NAME
          install_bird2() {
            DEBIAN_FRONTEND=noninteractive apt-get update && \
              DEBIAN_FRONTEND=noninteractive apt-get install -y bird2 \
              -o Dpkg::Options::="--force-confdef" \
              -o Dpkg::Options::="--force-confold"
            if [ $? -eq 0 ]; then
              echo "bird2 installation succeeded" >> /root/bird2-install.log
              return 0
            else
              echo "bird2 installation failed" >> /root/bird2-install.log
              return 1
            fi
          }       
          # Loop until the installation succeeds
          until install_bird2; do
            echo "Installation failed, retrying..." >> /root/bird2-install.log
            sleep 5 # Wait for 5 seconds before retrying
          done
          echo "Installation Completed" >> /root/bird2-install.log
          # Create the bird2 configuration file
      - path: /usr/local/bin/bird-config.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          # Replace IP address in the bird configuration file
          echo "Replacing IP address in the bird configuration file" >> /root/pre-install.log
          INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
          IP_ADDR=$(ip -o -4 addr show "$INTF_NAME" | awk '{print $4}' | cut -d/ -f1)
          sed -i "s/__IP_ADDRESS__/$IP_ADDR/g" /etc/bird/bird.conf
    runcmd:
      - /usr/local/bin/bird-config.sh
      - /usr/local/bin/setup-bgp.sh
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-k3s-controller
  namespace: skycluster-system
  labels:
    skycluster.io/managed-by: skycluster
    skycluster.io/script-type: cloud-init
    skycluster.io/script-target: provider-init
    skycluster.io/script-init: k3s-controller
data:
  cloud-init: |
    #cloud-config
    write_files:
      - path: /usr/local/bin/k3s-install.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          export USERNAME=`whoami`
          export K3S_HOME=/home/$USERNAME/k3s
          export KUBECONFIG=$K3S_HOME/k3s.yaml
          export K3S_BIN="/usr/local/bin"
          
          # Set timezone to avoid potential issues with TLS certs
          timedatectl set-timezone America/Toronto

          ARCH=$(uname -m)
          if [[ "$ARCH" == "x86_64" ]]; then
            export K3S_URL_FILE="https://github.com/k3s-io/k3s/releases/download/v1.33.3+k3s1/k3s"
          elif [[ "$ARCH" == "aarch64" ]]; then
            export K3S_URL_FILE="https://github.com/k3s-io/k3s/releases/download/v1.33.4%2Bk3s1/k3s-arm64"
          else
            echo "Unsupported architecture: $ARCH" >&2
            exit 1
          fi

          mkdir -p $K3S_HOME
          mkdir -p $K3S_BIN
          mkdir -p $K3S_HOME/scripts
          mkdir -p $K3S_HOME/logs
          
          exec > "$K3S_HOME/logs/k3s-install-$(date +'%Y-%m-%d_%H-%M').log" 2>&1

          export INTF_NAME=$(ip route get 8.8.8.8 | awk '{print $5; exit}')
          if ! ip -o -4 a show | grep -q $INTF_NAME; then
            echo "Error: interface not found."
            exit 1
          fi
          export NODE_IP=`ip -o -4 a show $INTF_NAME | awk '{print $4}' | cut -d/ -f1`
          export PUBLIC_IP=`curl ifconfig.io`

          ADVERTISE_IP=$PUBLIC_IP
          if [ -z "$PUBLIC_IP" ]; then
            echo "Failed to retrieve public IP. Use node ip instead."
            ADVERTISE_IP=$NODE_IP
          fi

          max_retries=10
          retry_count=0
          install_success=false
          while [ $retry_count -lt $max_retries ]; do
            if curl --max-time 80 -sfL --retry 3 "$K3S_URL_FILE" -o "$K3S_BIN/k3s"; then 
              echo "INFO: Downloaded k3s binary"
              chmod +x "$K3S_BIN/k3s"
              echo "Installing k3s..."
              if curl -sfL https://get.k3s.io | \
                INSTALL_K3S_SKIP_DOWNLOAD=true \
                K3S_KUBECONFIG_MODE="644" \
                INSTALL_K3S_EXEC=" \
                  --cluster-cidr __CLUSTER_CIDR__ \
                  --advertise-address $ADVERTISE_IP \
                  --node-ip $NODE_IP \
                  --service-cidr __SERVICE_CIDR__ \
                  --flannel-backend=vxlan \
                  --disable-network-policy \
                  --disable=traefik \
                  --node-label skycluster.io/node-type=control-plane \
                  --node-label skycluster.io/provider-platform=__PROVIDERPLATFORM__ \
                  --node-label skycluster.io/provider-region=__REGION__ \
                  --node-label skycluster.io/provider-identifier=__PROVIDERPLATFORM__-__REGION__-__ZONE__ \
                  --node-label topology.kubernetes.io/region=__PROVIDERPLATFORM__-__REGION__-__ZONE__ \
                  --node-label topology.kubernetes.io/zone=__PROVIDERPLATFORM__-__REGION__-__ZONE__ \
                  --node-label submariner.io/gateway=true" sh -; then
                install_success=true
                break
              else
                echo "Attempt $(($retry_count + 1)) of $max_retries failed. Retrying..." 
                retry_count=$(($retry_count + 1))
                sleep 5
              fi
            else
              echo "Downloading k3s Attempt $(($retry_count + 1)) of $max_retries failed. Retrying..."
              retry_count=$(($retry_count + 1))
              sleep 5
            fi
          done
          if [ "$install_success" = false ]; then
            echo "Error: Failed to install k3s after $max_retries attempts." 
            exit 1
          fi
          sudo cp /etc/rancher/k3s/k3s.yaml $K3S_HOME/k3s.yaml
          if [ $? -ne 0 ]; then
            echo "Error: Failed to copy k3s.yaml." 
            exit 1
          fi
          sudo chown $USERNAME $K3S_HOME/k3s.yaml 
          if [ $? -ne 0 ]; then
            echo "Error: Failed to change ownership of k3s.yaml." 
            exit 1
          fi
          TOKEN=`sudo cat /var/lib/rancher/k3s/server/node-token`
          if [ $? -ne 0 ]; then
            echo "Error: Failed to read the node token." 
            exit 1
          fi
          echo $TOKEN | tee $K3S_HOME/k3s.token > /dev/null
          if [ $? -ne 0 ]; then
            echo "Error: Failed to write the node token to the file." 
            exit 1
          fi
          jq -n --arg token "$TOKEN" --arg node_ip "$NODE_IP" '{"token":$token,"node_ip":$node_ip}' >> "$K3S_HOME/k3s.token.ip.json"
      - path: /usr/local/bin/k3s-calico.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          set -e

          # Redirect all output to output.log
          exec > /root/k3s-calico.log 2>&1

          # Function to wait for kubeconfig generation
          wait_for_kubeconfig() {
            local retries=50
            local wait=5
            for ((i=1;i<=retries;i++)); do
              if sudo kubectl config view --flatten > /dev/null 2>&1; then
                echo "Kubeconfig is valid."
                return 0
              else
                echo "Kubeconfig file not generated yet. Attempt $i/$retries."
                sleep $wait
              fi
            done
            echo "kubeconfig file not generated after $retries attempts!"
            exit 1
          }

          wait_for_kubeconfig

          # export PRIVATE_REGISTRY=__PRIVATE_REG_NAME__

          # Function to apply Tigera Operator with retries
          apply_tigera_operator() {
            local retries=5
            local wait=10
            for ((i=1;i<=retries;i++)); do

              # Define the URL and output file
              URL="https://raw.githubusercontent.com/projectcalico/calico/v3.30.2/manifests/tigera-operator.yaml"
              OUTPUT_FILE="tigera-operator.yaml"

              # Download the file
              curl -L "$URL" -o "$OUTPUT_FILE"

              # If PRIVATE_REGISTRY is set, replace quay.io with its value in tigera-operator.yaml and custom-resources.yaml
              # if [ "$PRIVATE_REGISTRY" != "__PRIVATE_REG_NAME__" ]; then
              #  sed -i "s?quay.io?$PRIVATE_REGISTRY?g" "$OUTPUT_FILE"
              # fi

              if kubectl create -f "$OUTPUT_FILE"; then
                echo "Tigera Operator applied successfully."
                return 0
              else
                echo "Failed to apply Tigera Operator. Attempt $i/$retries."
                sleep $wait
              fi
            done
            echo "Failed to apply Tigera Operator after $retries attempts."
            exit 1
          }

          # Apply Tigera Operator
          apply_tigera_operator

          # Wait for Tigera Operator deployment to be available with retries
          echo "Waiting for Tigera Operator to be ready..."
          retries=12
          wait=10
          for ((i=1;i<=retries;i++)); do
            if kubectl wait deployment/tigera-operator -n tigera-operator --for=condition=Available --timeout=30s; then
              echo "Tigera Operator is ready."
              break
            else
              echo "Tigera Operator not ready yet. Attempt $i/$retries."
              if [ "$i" -eq "$retries" ]; then
                echo "Tigera Operator did not become ready in time."
                exit 1
              fi
              sleep $wait
            fi
          done

          # Wait for APIServer CRD to be established before creating the object
          echo "Waiting for APIServer CRD to be available..."
          retries=30
          wait=10
          for ((i=1;i<=retries;i++)); do
            if kubectl get crd apiservers.operator.tigera.io > /dev/null 2>&1; then
              echo "APIServer CRD is available."
              break
            else
              echo "APIServer CRD not available yet. Attempt $i/$retries."
              if [ "$i" -eq "$retries" ]; then
                echo "APIServer CRD did not become available in time."
                exit 1
              fi
              sleep $wait
            fi
          done
          
          cat <<EOF | kubectl apply -f -
          apiVersion: operator.tigera.io/v1
          kind: APIServer
          metadata:
            name: default
          spec: {}
          EOF
      - path: /usr/local/bin/k3s-metallb.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          set -e

          # Redirect all output to output.log
          exec > /root/k3s-metallb.log 2>&1

          # export PRIVATE_REGISTRY=__PRIVATE_REG_NAME__

          # Function to wait for kubeconfig generation
          wait_for_kubeconfig() {
            local retries=50
            local wait=5
            for ((i=1;i<=retries;i++)); do
              if sudo kubectl config view --flatten > /dev/null 2>&1; then
                echo "Kubeconfig is valid."
                return 0
              else
                echo "Kubeconfig file not generated yet. Attempt $i/$retries."
                sleep $wait
              fi
            done
            echo "kubeconfig file not generated after $retries attempts!"
            exit 1
          }

          wait_for_kubeconfig

          install_metallb() {
            local retries=5
            local wait=10
            for ((i=1;i<=retries;i++)); do
              URL="https://raw.githubusercontent.com/metallb/metallb/v0.15.2/config/manifests/metallb-native.yaml"
              # URL="https://skycluster.io/configs/metallb-native-v0.14.9.yaml"
              OUTPUT_FILE="metallb.yaml"
              curl -L "$URL" -o "$OUTPUT_FILE"

              # If PRIVATE_REGISTRY is set
              # if [ "$PRIVATE_REGISTRY" != "__PRIVATE_REG_NAME__" ]; then
              #  sed -i "s?quay.io?$PRIVATE_REGISTRY?g" "$OUTPUT_FILE"
              # fi
              if kubectl create -f $OUTPUT_FILE; then
                echo "Metallb applied successfully."
                return 0
              else
                echo "Failed to apply Metallb. Attempt $i/$retries."
                sleep $wait
              fi
            done
            echo "Failed to apply Metallb after $retries attempts."
            exit 1
          }
          install_metallb        
      - path: /usr/local/bin/k3s-gw-api.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          # set -e

          # # Redirect all output to output.log
          # exec > /root/k3s-gw-api.log 2>&1

          # # Function to wait for kubeconfig generation
          # wait_for_kubeconfig() {
          #   local retries=50
          #   local wait=5
          #   for ((i=1;i<=retries;i++)); do
          #     if sudo kubectl config view --flatten > /dev/null 2>&1; then
          #       echo "Kubeconfig is valid."
          #       return 0
          #     else
          #       echo "Kubeconfig file not generated yet. Attempt $i/$retries."
          #       sleep $wait
          #     fi
          #   done
          #   echo "kubeconfig file not generated after $retries attempts!"
          #   exit 1
          # }

          # # Wait for kubeconfig
          # wait_for_kubeconfig

          # install_gw_api() {
          #   local retries=5
          #   local wait=10
          #   for ((i=1;i<=retries;i++)); do
          #     if kubectl create -f https://skycluster.io/configs/gateway-api-standard-v1.2.0.yaml; then
          #       echo "Gateway API applied successfully."
          #       return 0
          #     else
          #       echo "Failed to install Gateway API. Attempt $i/$retries."
          #       sleep $wait
          #     fi
          #   done
          #   echo "Failed to apply Gateway API after $retries attempts."
          #   exit 1
          # }
          # install_gw_api
      - path: /usr/local/bin/helm-install.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Redirect all output to output.log
          exec > /root/helm-install.log 2>&1

          HELM_VERSION="v3.18.5"

          ARCH=$(uname -m)
          case "$ARCH" in
              x86_64) ARCH="amd64" ;;
              aarch64 | arm64) ARCH="arm64" ;;
              armv7l) ARCH="arm" ;;
              *) echo "Unsupported architecture: $ARCH"; exit 1 ;;
          esac

          TMP_DIR=$(mktemp -d)
          cd "$TMP_DIR"

          # https://get.helm.sh/helm-v3.18.5-linux-amd64.tar.gz
          curl -sSL "https://get.helm.sh/helm-$HELM_VERSION-linux-$ARCH.tar.gz" -o helm.tar.gz
          tar -xzf helm.tar.gz
          sudo mv linux-$ARCH/helm /usr/local/bin/helm

          cd -
          rm -rf "$TMP_DIR"

          echo "Helm $(helm version --short) installed successfully."
      - path: /usr/local/bin/k3s-istio.sh
        owner: root:root
        permissions: '0755'
        content: |
          #!/bin/bash
          set -e

          # Redirect all output to output.log
          exec > /root/k3s-istio.log 2>&1

          export PRIVATE_REGISTRY=__PRIVATE_REG_NAME__

          # Function to wait for kubeconfig generation
          wait_for_kubeconfig() {
            local retries=50
            local wait=5
            for ((i=1;i<=retries;i++)); do
              if sudo kubectl config view --flatten > /dev/null 2>&1; then
                echo "Kubeconfig is valid."
                return 0
              else
                echo "Kubeconfig file not generated yet. Attempt $i/$retries."
                sleep $wait
              fi
            done
            echo "kubeconfig file not generated after $retries attempts!"
            exit 1
          }

          wait_for_kubeconfig

          make_temp_kubeconfig() {
            local tmpfile
            tmpfile="$(mktemp -t kubeconfig.XXXXXX)"
            # shellcheck disable=SC2064

            # Build the file from kubectl (using sudo to mirror your kubectl invocations)
            # Note: --raw preserves auth/provider fields; --flatten embeds referenced certs/keys.
            sudo kubectl config view --raw --flatten --minify > "$tmpfile"

            echo "$tmpfile"
          }

          KUBECONFIG="$(make_temp_kubeconfig)"
          echo "Using temporary kubeconfig at: $KUBECONFIG"

          install_istio() {
            local retries=5
            local wait=10
            for ((i=1;i<=retries;i++)); do
              if helm repo add istio https://istio-release.storage.googleapis.com/charts && helm repo update; then
                echo "Helm repo for Istio added successfully."
                break
              else
                echo "Failed to add Helm repo. Attempt $i/$retries."
                sleep $wait
              fi
            done

            # Install Istio base
            for ((i=1;i<=retries;i++)); do
              if helm upgrade --install istio-base istio/base -n istio-system --create-namespace --kubeconfig "$KUBECONFIG" --version 1.27.0; then
                echo "Istio base installed successfully."
                return 0
              else
                echo "Failed to install Istio base. Attempt $i/$retries."
                sleep $wait
              fi
            done
            echo "Failed to install Istio base after $retries attempts."
            exit 1
          }
          install_istio

          install_istio_deploy() {
            local retries=5
            local wait=10
            # Install Istio discovery (istiod)
            for ((i=1;i<=retries;i++)); do
              if helm upgrade --install istiod istio/istiod -n istio-system --kubeconfig "$KUBECONFIG"; then
                echo "Istio control plane (istiod) installed successfully."
                return 0
              else
                echo "Failed to install istiod. Attempt $i/$retries."
                sleep $wait
              fi
            done
            echo "Failed to apply istio deployment after $retries attempts."
            exit 1
          }
          install_istio_deploy
          kubectl label namespace default istio-injection=enabled

    runcmd:
      - /usr/local/bin/k3s-install.sh
      # - /usr/local/bin/k3s-calico.sh
      - /usr/local/bin/k3s-metallb.sh
      - /usr/local/bin/helm-install.sh
      # - /usr/local/bin/k3s-istio.sh

{{ end }}